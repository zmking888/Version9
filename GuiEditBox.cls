VERSION 1.0 CLASS
BEGIN
  MultiUse = -1  'True
  Persistable = 0  'NotPersistable
  DataBindingBehavior = 0  'vbNone
  DataSourceBehavior  = 0  'vbNone
  MTSTransactionMode  = 0  'NotAnMTSObject
END
Attribute VB_Name = "GuiEditBox"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
' M2000 ver 1.
Option Explicit
' chr(34) is """" maybe somewhere in a module as public
Const mway As Long = DT_NOPREFIX Or DT_NOCLIP
Public textinform As String
Private mysp As Boolean, col() As Variant
Private TextPixelOffset As Long
Private nochange As Boolean
Public tabwidth As Long
Public SeekNextLine As Boolean
Public ShadowMarks As Boolean
Public OtherSymbols As String
Public LineComment1 As String
Public LineComment2 As String
Public ExtraFront As String
Public CommentSymbols As String
Public ComSymbolsWidth As Long
Public MultiLineComment1 As String
Private mMultiLineComment2 As String
Public Form1mn1Enabled As Boolean
Public Form1mn2Enabled As Boolean
Public Form1mn3Enabled As Boolean
Public Form1sdnEnabled As Boolean
Public Form1supEnabled As Boolean
Public Form1mscatEnabled As Boolean
Public Form1rthisEnabled As Boolean
Private mColorCollection1 As String
Public ColorCollection2 As String
Public ColorCollection3 As String
Public ColorCollection4 As String
Public EditTextWord As Boolean
Public ColorSet As Long
Public NumberOnly As Boolean
Public NumberIntOnly As Boolean
Public WithEvents glistN As gList
Attribute glistN.VB_VarHelpID = -1
Private blockKeyboard As Boolean
Private LastDocTitle$, para1 As Long, PosPara1 As Long, Para2 As Long, PosPara2 As Long, Para3 As Long, PosPara3 As Long
Public fState As Long
Public WithEvents mDoc As Document    ' document
Attribute mDoc.VB_VarHelpID = -1
Dim WithEvents mDoc1 As Document  ' header
Attribute mDoc1.VB_VarHelpID = -1
Dim UndoDoc As New Document  ' one level of undo no events ' no break lines
Dim undopara As Long, undopos As Long, undotext As String, undomode As Long, undotexthtml As String
Dim Redopara As Long, Redopos As Long, Redotext As String, Redomode As Long
Dim undostate As Boolean
Dim Redostate As Boolean
Dim NoHeadwrap As Boolean
Public SkipProcAtExitFocus As Boolean
Private Type UndoChain
    undopara As Long
    undopos As Long
    undomode As Long
    undotext As String
End Type
Dim NeoUndo As Long, UndoMax As Long
Dim NeoRedo As Long, RedoMax As Long

Dim MultiUndo() As UndoChain
Dim MultiRedo() As UndoChain

Dim GetUndoNext As Boolean
Dim myfilename As String
Dim all As Long, onelineheight As Long
''Event inform(tLine As Long, tPos As Long)
Public LastSelStart As Long
Public NoMark As Boolean
Public NoTitle As Boolean, TitleStay As Boolean
Private mNoColor As Boolean, mNoColor1 As Boolean
Public Title As String
Public UsedAsTextBox As Boolean  '' only in m2000. Enter exit - use maxchar - No wrap
Private mEditDoc As Boolean
Public AutoNumber As Boolean
Public Charpos As Long
Public showparagraph As Boolean
Private showparagraphWork As Boolean
Public SelectionColor As Long
Public SelectionTextColor As Long
Private showparagraphonce As Boolean
Private mNoWrap As Boolean
Private BlockStartPara As Long, BlockStartPos As Long, BlockStartLine As Long, BlockTopline As Long
Private BlockStartCursor As Long, BlockEndCursor As Long
Private BlockEndPara As Long, BlockEndPos As Long, BlockEndline As Long, BlockBottomline As Long
Private Declare Function CopyFromLParamToRect Lib "user32" Alias "CopyRect" (lpDestRect As RECT, ByVal lpSourceRect As Long) As Long
Private Declare Function GlobalAlloc Lib "KERNEL32" (ByVal wFlags As Long, ByVal dwBytes As Long) As Long
Private Declare Function GlobalFree Lib "KERNEL32" (ByVal hMem As Long) As Long
Private Declare Function GlobalLock Lib "KERNEL32" (ByVal hMem As Long) As Long
Private Declare Function GlobalReAlloc Lib "KERNEL32" (ByVal hMem As Long, ByVal dwBytes As Long, ByVal wFlags As Long) As Long
Private Declare Function GlobalSize Lib "KERNEL32" (ByVal hMem As Long) As Long
Private Declare Function GlobalUnlock Lib "KERNEL32" (ByVal hMem As Long) As Long
Private Const GMEM_DDESHARE = &H2000
Private Const GMEM_DISCARDABLE = &H100
Private Const GMEM_DISCARDED = &H4000
Private Const GMEM_FIXED = &H0
Private Const GMEM_INVALID_HANDLE = &H8000
Private Const GMEM_LOCKCOUNT = &HFF
Private Const GMEM_MODIFY = &H80
Private Const GMEM_MOVEABLE = &H2
Private Const GMEM_NOCOMPACT = &H10
Private Const GMEM_NODISCARD = &H20
Private Const GMEM_NOT_BANKED = &H1000
Private Const GMEM_NOTIFY = &H4000
Private Const GMEM_SHARE = &H2000
Private Const GMEM_VALID_FLAGS = &H7F72
Private Const GMEM_ZEROINIT = &H40
Private Const GPTR = (GMEM_FIXED Or GMEM_ZEROINIT)
Private Const GMEM_LOWER = GMEM_NOT_BANKED
Private Declare Sub CopyMemory Lib "KERNEL32" Alias "RtlMoveMemory" ( _
    lpvDest As Any, lpvSource As Any, ByVal cbCopy As Long)
Private Declare Function GetClipboardData Lib "user32" _
    (ByVal wFormat As Long) As Long
    Private Declare Function SetClipboardData Lib "user32" _
    (ByVal wFormat As Long, ByVal hMem As Long) As Long
    Private Declare Function OpenClipboard Lib "user32" _
    (ByVal hWND As Long) As Long
Private Declare Function CloseClipboard Lib "user32" _
    () As Long
    Private Declare Function IsClipboardFormatAvailable Lib "user32" _
    (ByVal wFormat As Long) As Long
    Private Declare Function GetLocaleInfo Lib "KERNEL32" Alias "GetLocaleInfoW" (ByVal Locale As Long, ByVal LCType As Long, ByVal lpLCData As Long, ByVal cchData As Long) As Long
Private Declare Function GetKeyboardLayout& Lib "user32" (ByVal dwLayout&) ' not NT?
Private Const DWL_ANYTHREAD& = 0
Const LOCALE_ILANGUAGE = 1
    ' for Gui purposes
Private s$
Public ctrlName As String
Private mesCtrlName As String
Dim mIndex As Long, mStayOpen As Boolean
Dim Callback As GuiM2000
Dim oldEditDoc As Boolean
Dim white As Long, black As Long, dimm1 As Long, dimm2 As Long
Dim Quit
Private OldPar As Long, dragCharpos As Long
Public Property Get GetCallBack() As Form
Set GetCallBack = Callback
End Property
Public Sub Construct(there As Form, name$)
 mIndex = -1
 Set Callback = there
 On Error Resume Next
 ctrlName = GetTag$
 Set glistN = there.Controls.Add("m2000.glist", ctrlName)
 there.AddGuiControl Me
 glistN.Dynamic
 there.Controls(ctrlName).TabStop = True
 mesCtrlName = name$
End Sub
Public Sub ConstructArray(there As Form, name$, i As Long)
 Set Callback = there
 On Error Resume Next
 ctrlName = GetTag$
 Set glistN = there.Controls.Add("m2000.glist", ctrlName)
 mIndex = i
 there.AddGuiControl Me
 glistN.Dynamic
 there.Controls(ctrlName).TabStop = True
 mesCtrlName = name$
End Sub

Public Sub SetUp()
tabwidth = 6
EditTextWord = True

black = 0
dimm1 = rgb(100, 200, 160)
dimm2 = rgb(200, 120, 60)
' for vb6 coloring &HFFFFFF  - no checking for number of digits
ColorCollection4 = "|&H|&O|"
ExtraFront = "&"
OtherSymbols = ",;"
LineComment1 = "\"
LineComment2 = "'"
CommentSymbols = "[\][\]"
ComSymbolsWidth = 2
MultiLineComment1 = "\*"
MultiLineComment2 = "*/"
Dim ff As New StdFont
With Callback
white = .Controls(1).ForeColor
ff.name = .CtrlFontName
ff.charset = Form1.DIS.Font.charset
ff.Size = .CtrlFontSize
ff.bold = .CtrlFontBold
End With
mStayOpen = True
With glistN
WordCharLeft = " ,[]"
WordCharRight = " ,[]"
.NoEscapeKey = True
.bypassfirstClick = True
.Vertical = True
.DropEnabled = True
.DragEnabled = True
.PreserveNpixelsHeaderRightTwips = 8
NoMark = False
mNoColor = True
mNoColor1 = True
FileName = vbNullString
glistN.DragEnabled = False
.backcolor = rgb(200, 120, 60)
Set .Font = ff
.ForeColor = white
.dcolor = Callback.Controls(1).dcolor
.LeftMarginPixels = 8
End With
'glistN.addpixels = 0
TextPixelOffset = Int(glistN.TextHeightOffset)

EditDoc = True
nowrap = False
enabled = True
SetME
mDoc.ForEditBox = True
End Sub
Sub Show()
If glistN Is Nothing Then Exit Sub
TextPixelOffset = Int(glistN.TextHeightOffset)
'glistN.ShowPan
glistN.PrepareToShow 5
End Sub
Public Sub PasteDoc(thisdoc As String)

 Const CF_UNICODETEXT = 13
 ClearRedo
If thisdoc = vbNullString Then
thisdoc = GetTextData(CF_UNICODETEXT)
Else
PushUndo
End If

undotext = thisdoc
undopara = mDoc.MarkParagraphID
If mDoc.TextParagraphLen(mDoc.MarkParagraphID) = 0 And glistN.SelStart > 0 Then
undopos = 1 + CharPosStart - glistN.SelStart
Else
undopos = CharPosStart
End If
undomode = 0
mDoc.InsertDoc mDoc.MarkParagraphID, Charpos, thisdoc
'ReColorBlock
Render
End Sub
Private Function Myleft$(a As Variant, pos As Variant)
Myleft$ = Mid$(a, 1, pos)
End Function
Private Function GetTextData(ByVal lFormatId As Long) As String
Dim bData() As Byte, sr As String, sr1 As String
sr1 = Clipboard.GetText(1)
If (OpenClipboard(0) <> 0) Then

        
        If (GetBinaryData(lFormatId, bData())) Then
        sr = bData
    
     If IsWine Then
            sr1 = Myleft$(sr, Len(sr1))
            GetTextData = Myleft$(sr1, Len(sr1))
    Else
                GetTextData = Myleft$(sr, Len(sr1))
    End If
    
          
        End If

End If
CloseClipboard
End Function
Private Function GetClipboardMemoryHandle( _
        ByVal lFormatId As Long _
    ) As Long

    

    If (IsClipboardFormatAvailable(lFormatId) <> 0) Then
         
        GetClipboardMemoryHandle = GetClipboardData(lFormatId)
        
    End If
End Function
Private Function GetBinaryData( _
        ByVal lFormatId As Long, _
        ByRef bData() As Byte _
    ) As Boolean

Dim hMem As Long, lSize As Long, lPtr As Long
    

    Erase bData
    
    hMem = GetClipboardMemoryHandle(lFormatId)

    If (hMem <> 0) Then

        lSize = GlobalSize(hMem)

        lPtr = GlobalLock(hMem)
        If (lSize > 0) Then

            ReDim bData(0 To lSize - 2) As Byte

            CopyMemory bData(0), ByVal lPtr, lSize - 1
        End If

        GlobalUnlock hMem

        GetBinaryData = (lSize > 0)

    End If
End Function


Public Sub HorSrcoll(widthtwips As Long)
glistN.PanPos = widthtwips
End Sub
Public Property Get FileName() As String
FileName = myfilename
End Property
Sub NewTitle(RHS As String, addpixelstoo As Long, Optional factor As Single = 1)
Title = RHS
Set mDoc1 = New Document
If Title = vbNullString Then
Else
NoHeadwrap = False
mDoc1.textDoc = Title

glistN.VerticalCenterText = True
If mDoc1.DocLines >= glistN.lines + 1 Then
mDoc1.EmptyDoc
NoHeadwrap = True
mDoc1.textDoc = Title
End If
glistN.HeadLine = vbNullString ' reset
glistN.HeadLine = " " ' give a fake headline
onelineheight = glistN.HeadlineHeight + addpixelstoo
glistN.addpixels = 4 * factor ' 'line spacing
End If
all = mDoc.DocLines
glistN.MultiLineEditBox = True
glistN.ShowBar = True
glistN.ShowBar = False  ' now is in autohide mode
glistN.StickBar = True
mDoc.WrapAgain
mDoc1.WrapAgain
glistN.PrepareToShow 10
all = mDoc.DocLines
glistN.CalcAndShowBar
End Sub
Public Property Let FileName(ByVal RHS As String)
myfilename = RHS
onelineheight = 0
Dim thisdoc As New Document, header As New Document
Set mDoc = thisdoc
mDoc.ColorEvent = True
Set mDoc1 = header
para1 = 0
PosPara1 = 0
Para2 = 0
PosPara2 = 0
Para3 = 0
PosPara3 = 0
BlockStartPara = 0
BlockStartPos = 0
BlockStartLine = 0
BlockTopline = 0
BlockStartCursor = 0
BlockEndCursor = 0
BlockEndPara = 0
BlockEndPos = 0
BlockEndline = 0
BlockBottomline = 0
Dim i As Long
glistN.NoCaretShow = True
ClearRedo
ClearUndo
If RHS = vbNullString Then
mDoc.textDoc = vbNullString
Else
mDoc.textDoc = ReadUnicodeOrANSI(RHS)
End If

Dim what$, ThatPara As Long, pastchars
pastchars = mDoc.TextParagraphLine(1, what$, ThatPara)
mDoc.MarkParagraphID = ThatPara
NoTitle = Title = vbNullString
nowrap = True


If Not NoTitle Then
mDoc1.textDoc = Title

glistN.HeadLine = vbNullString ' reset
glistN.HeadLine = " " ' give a fake headline
onelineheight = glistN.HeadlineHeight
End If
''glistN.AddPixels = 4  ' use this before  ---- changed for m2000 version 2
all = mDoc.DocLines
glistN.MultiLineEditBox = True
glistN.ShowBar = True
glistN.ShowBar = False  ' now is in autohide mode
glistN.ShowMe
glistN.StickBar = True
mDoc.WrapAgain
mDoc1.WrapAgain
glistN.PrepareToShow 10
'glistN.ShowMe2
all = mDoc.DocLines
glistN.CalcAndShowBar
'glistN.FloatList = True
End Property
Public Sub ResetSelColors()
SelectionTextColor = &HFFFFFF
SelectionColor = &H666666
End Sub



Private Sub Class_Initialize()
Set mDoc = New Document
mDoc.ColorEvent = True
Set mDoc1 = New Document
ResetSelColors
mDoc.lcid = cLid
mDoc1.lcid = cLid
BlockStartPara = BlockEndPara
BlockStartPos = BlockEndPos
undopara = -1
Redopara = -1
mIndex = -1
End Sub
Private Sub Class_Terminate()
Quit = True
Set glistN = Nothing
End Sub

Private Sub glistN_addone(that As String)  '
' push undo addone
' from delete or backspace..
If Not enabled Then Exit Sub
ClearRedo
If that = vbCrLf Then
PushUndo
undopara = mDoc.MarkParagraphID
undotext = that
undopos = SelStart
undomode = 2

ElseIf undomode = 1 And undotext <> "" Then
If undopos = SelStart Then
' we add after
undotext = undotext + that
Else
undotext = that + undotext
undopos = SelStart
End If
Else
PushUndo
undopara = mDoc.MarkParagraphID
undotext = that
undopos = SelStart ' always the left side of char - so 0 is inside
undomode = 1
End If

End Sub
Public Sub AddUndo(that As String)
If Not enabled Then Exit Sub
ClearRedo
If that = vbCrLf Then
PushUndo
undopara = mDoc.MarkParagraphID
undotext = that
undopos = SelStart
undomode = 2

Else
PushUndo
undopara = mDoc.MarkParagraphID
undotext = that
undopos = SelStart ' always the left side of char - so 0 is inside
undomode = 1
End If

End Sub
Public Sub RemoveUndo(that As String)
ClearRedo
If that = vbCrLf Then
PushUndo
undopara = mDoc.MarkParagraphID
undotext = that
undopos = SelStart
undomode = 3
Else
PushUndo
undopara = mDoc.MarkParagraphID
undotext = that
If mDoc.TextParagraphLen(mDoc.MarkParagraphID) = 0 And glistN.SelStart > 0 Then
undopos = 1 + SelStart - glistN.SelStart
Else
undopos = SelStart
End If
undomode = 0
End If
End Sub
Public Sub ManualInform()
If Not glistN.enabled Then Exit Sub
If glistN.SelStart = 0 Then
  If mIndex >= 0 Then
   Callback.Callback mesCtrlName + ".Inform(" + Str(mIndex) + "," + Str(glistN.ListIndex + 1) + ", 1)"
   Else
      Callback.Callback mesCtrlName + ".Inform(" + Str(glistN.ListIndex + 1) + ", 1)"
      End If
Else
  If mIndex >= 0 Then
   Callback.Callback mesCtrlName + ".Inform(" + Str(mIndex) + "," + Str(glistN.ListIndex + 1) + ", " + Str(glistN.SelStart) + ")"
   Else
      Callback.Callback mesCtrlName + ".Inform(" + Str(glistN.ListIndex + 1) + ", " + Str(glistN.SelStart) + ")"
      End If
End If
End Sub


Private Sub glistN_CheckGotFocus()
If Not locked Then
glistN.HideCaretOnexit = False
If glistN.ListIndex < 0 And glistN.listcount > 0 Then glistN.ListindexPrivateUse = 0

If enabled Then
glistN.NoCaretShow = NoMark

mNoColor = mNoColor1
glistN.ForeColor = black
glistN.backcolor = white

Else
mNoColor = True
glistN.NoCaretShow = False Or NoMark
glistN.ForeColor = white
glistN.backcolor = dimm1
End If
glistN.ShowMe
Else
mNoColor = True
End If

End Sub
Private Sub glistN_CheckLostFocus()

If Not locked Then
If mStayOpen And Not SkipProcAtExitFocus Then
glistN.NoCaretShow = NoMark
glistN.HideCaretOnexit = True
If glistN.Visible Then
If NumberOnly Or UsedAsTextBox Then
SelStartSilent = 0
BlockStartPara = BlockEndPara
BlockStartPos = BlockEndPos
glistN.MarkNext = 0
End If
glistN.ShowPan
End If

Exit Sub
End If
If Not SkipProcAtExitFocus Then
mNoColor = True
glistN.NoCaretShow = False Or NoMark
glistN.HideCaretOnexit = True
glistN.ForeColor = white
If glistN.BackStyle <> 1 Then

glistN.backcolor = dimm2
End If
glistN.PanPos = 0: glistN.PrepareToShow

Else
'
End If

Else

End If

'RaiseEvent LostFocus
End Sub

Private Sub glistN_CorrectCursorAfterDrag()
    If Not mDoc.InvalidPara(OldPar) Then
        SelLengthSilent = 0
        mDoc.MarkParagraphID = OldPar
        glistN.enabled = False
        ParaSelStart = dragCharpos
        glistN.enabled = True
        ManualInform
        OldPar = 0
    End If
End Sub





Private Sub glistN_HaveMark(Yes As Boolean)
Yes = HaveMarkedText
End Sub

Private Sub glistN_MarkCut(ThatData As String)
ThatData = undotext
End Sub
Private Sub glistN_DragOverDone(a As Boolean)

If Not mDoc.InvalidPara(OldPar) Then
        a = True
        SelLengthSilent = 0
        mDoc.MarkParagraphID = OldPar
        glistN.enabled = False
        ParaSelStart = dragCharpos
        glistN.enabled = True
        ManualInform
        OldPar = 0
    End If
End Sub
Private Sub glistN_DragOverNow(a As Boolean)
If OldPar = 0 Then
a = True
 SelLengthSilent = 0
 OldPar = mDoc.MarkParagraphID
 dragCharpos = Charpos
End If
End Sub
Private Sub glistN_Maybelanguage()
If Not glistN.enabled Then Exit Sub
If glistN.SelStart = 0 Then
  If mIndex >= 0 Then
   Callback.Callback mesCtrlName + ".Inform(" + Str(mIndex) + "," + Str(glistN.ListIndex + 1) + ", 1)"
   Else
      Callback.Callback mesCtrlName + ".Inform(" + Str(glistN.ListIndex + 1) + ", 1)"
      End If
Else
  If mIndex >= 0 Then
   Callback.Callback mesCtrlName + ".Inform(" + Str(mIndex) + "," + Str(glistN.ListIndex + 1) + ", " + Str(glistN.SelStart) + ")"
   Else
      Callback.Callback mesCtrlName + ".Inform(" + Str(glistN.ListIndex + 1) + ", " + Str(glistN.SelStart) + ")"
      End If
End If
Render
End Sub

Private Sub glistN_OutPopUp(x As Single, y As Single, myButton As Integer)
'
If mIndex >= 0 Then
   Callback.Callback mesCtrlName + ".PopUp(" + Str(mIndex) + "," + Str(x + Callback.Controls(ctrlName).Left) + "," + Str(y + Callback.Controls(ctrlName).Top) + "," + Str(myButton) + "," + Str(glistN.ListIndex + 1) + ")"
   Else
      Callback.Callback mesCtrlName + ".PopUp(" + Str(x + Callback.Controls(ctrlName).Left) + "," + Str(y + Callback.Controls(ctrlName).Top) + "," + Str(myButton) + "," + Str(glistN.ListIndex + 1) + ")"
      End If
End Sub

Private Sub glistN_PureListOff()
showparagraphWork = True
End Sub

Private Sub glistN_PureListOn()
showparagraphWork = False
End Sub

Private Sub glistN_PushMark2Undo(that As String)
ClearRedo
undopara = BlockEndPara
undotext = that
undomode = 1
undopos = SelStart
End Sub

Private Sub glistN_PushUndoIfMarked()
If HaveMarkedText Then PushUndo
End Sub



Private Sub glistN_RemoveOne(that As String)
' push undo removeone
If Not enabled Then Exit Sub

ClearRedo
If that = vbCrLf Then
PushUndo
undopara = mDoc.MarkParagraphID
undotext = that
undopos = SelStart
undomode = 3
ElseIf undomode = 0 And undotext <> "" Then
If undopos + Len(undotext) = SelStart Then
' we add after
undotext = undotext + that

Else
PushUndo
undopara = mDoc.MarkParagraphID
undotext = that
If mDoc.TextParagraphLen(mDoc.MarkParagraphID) = 0 And glistN.SelStart > 0 Then
undopos = 1 + SelStart - glistN.SelStart
Else
If glistN.ListIndex = all Then
undopos = SelStart - 1
Else
undopos = SelStart
End If
End If
 ' always the left side of char - so 0 is inside
undomode = 0
End If

Else
PushUndo
undopara = mDoc.MarkParagraphID
undotext = that
If mDoc.TextParagraphLen(mDoc.MarkParagraphID) = 0 And glistN.SelStart > 0 Then
undopos = 1 + SelStart - glistN.SelStart
Else
undopos = SelStart
End If
undomode = 0
End If
End Sub


Private Sub glistN_MayRefresh(ok As Boolean)
ok = Not HaveMarkedText
End Sub

Public Property Get MaxCharLength() As Long
MaxCharLength = glistN.maxchar
End Property

Public Property Let MaxCharLength(ByVal RHS As Long)
glistN.maxchar = RHS
End Property
Private Sub glistN_ChangeListItem(item As Long, content As String)
Dim selstart2 As Long, checklistindex As Long, old$
'' only for M2000, use NumberOnly
If NumberOnly Or NumberIntOnly Then
NumberOnly = True
If Len(content) > glistN.maxchar Then
Charpos = glistN.maxchar
glistN.SelStartEventAlways = glistN.SelStart - 1
Exit Sub
End If
If content = vbNullString Then
ElseIf Not ValidNum(content, False, NumberIntOnly) Then
undotext = vbNullString
content = mDoc.TextLine(item + 1)
Exit Sub
End If
End If
If UsedAsTextBox Then
If Len(content) > glistN.maxchar Then
Charpos = glistN.maxchar
glistN.SelStartEventAlways = glistN.SelStart - 1
Exit Sub
End If
End If
mDoc.TextLine(item + 1) = content
WrapMarkedPara
If all <> mDoc.DocLines Then
    Render
Else
    checklistindex = mDoc.FirstParagraphLine(mDoc.MarkParagraphID) + mDoc.TextParagraph2Line(mDoc.MarkParagraphID, Charpos, selstart2)
    If (checklistindex - glistN.ScrollFrom) >= glistN.lines + 1 Then
     glistN.ListindexPrivateUse = checklistindex
     glistN.ScrollTo checklistindex - glistN.lines
     glistN.SelStartEventAlways = selstart2
     

    
    ElseIf checklistindex < glistN.ScrollFrom Then
     glistN.ListindexPrivateUse = checklistindex
     glistN.ScrollTo checklistindex
          glistN.SelStartEventAlways = selstart2
    Else
    glistN.ListindexPrivateUse = checklistindex
    glistN.SelStart = selstart2
        End If
End If

End Sub

Private Sub glistN_ChangeSelStart(thisselstart As Long)
If glistN.ListIndex < 0 Then Exit Sub
Dim what$, ThatPara As Long, pastchars As Long
pastchars = mDoc.TextParagraphLine2(glistN.ListIndex + 1, what$, ThatPara, False)
Charpos = pastchars + glistN.SelStart

If Not glistN.enabled Then Exit Sub
If glistN.SelStart = 0 Then
inform glistN.ListIndex + 1, 1
  If mIndex >= 0 Then
   Callback.Callback mesCtrlName + ".Inform(" + Str(mIndex) + "," + Str(glistN.ListIndex + 1) + ", 1)"
   Else
      Callback.Callback mesCtrlName + ".Inform(" + Str(glistN.ListIndex + 1) + ", 1)"
      End If
Else
 inform glistN.ListIndex + 1, (glistN.SelStart)
  If mIndex >= 0 Then
   Callback.Callback mesCtrlName + ".Inform(" + Str(mIndex) + "," + Str(glistN.ListIndex + 1) + ", " + Str(glistN.SelStart) + ")"
   Else
      Callback.Callback mesCtrlName + ".Inform(" + Str(glistN.ListIndex + 1) + ", " + Str(glistN.SelStart) + ")"
      End If
End If
''glistN.PrepareToShow
On Error Resume Next
glistN.ShowMe
End Sub

Private Sub glistN_DragData(ThatData As String)
FillBlock
ThatData = UndoDoc.textDoc
 OldPar = mDoc.MarkParagraphID
 dragCharpos = Charpos
End Sub

Private Sub glistN_DragPasteData(ThatData As String)
Dim a() As String, k As Long
a() = Split(ThatData, ChrW(9))
OldPar = 0
PasteDoc Join(a(), "    ")
RelocateMarkedText

End Sub

Private Sub glistN_DropFront(ok As Boolean)
ok = False
' we need to know if we delete mark before paste data
' when we perform dragdrop to the same document
' by defult ok=false so we drop behind so we can delete marked text and then we paste
If HaveMarkedText Then
If glistN.ListIndex < BlockStartLine Then
' we are behind
ElseIf glistN.ListIndex = BlockStartLine Then
If glistN.SelStart < BlockStartCursor Then
Else
ok = True
End If
Else
ok = True
End If
End If
End Sub

Private Sub glistN_DropOk(ok As Boolean)
If HaveMarkedText Then
If ClickInsideMarkedText Then
Else
ok = True
End If
Else
ok = True
End If
End Sub

Private Sub glistN_ExposeListcount(cListCount As Long)
cListCount = all
End Sub

Private Sub gListN_ExposeRect(ByVal item As Long, ByVal thisrect As Long, ByVal thisHDC As Long, skip As Boolean)
Dim a As RECT, b As RECT, i As Long, pastchars As Long
Dim final$, fbypass As Boolean
Dim oldcolor As Long
Dim what$, ThatPara As Long
CopyFromLParamToRect a, thisrect
CopyFromLParamToRect b, thisrect
If UsedAsTextBox Then
b.Bottom = a.Bottom - 2
End If
Dim skipcolor As Boolean
oldcolor = glistN.ForeColor
If item < 0 Then  ' this is a headline
FillBack thisHDC, b, glistN.CapColor
  mDoc1.TextParagraphLine2 1, what$, ThatPara, False
  showparagraphonce = False
   glistN.HeadlineHeight = mDoc1.DocLines * onelineheight

  For i = 1 To mDoc1.DocLines
  
    PrintItem2 thisHDC, mDoc1.TextLine2(i, False, True), a
    a.Top = a.Top + onelineheight
  Next i
 ' RaiseEvent ExposeRect(item, thisrect, thisHDC, skip)
  skip = True
   Exit Sub
   
Else
showparagraphWork = showparagraph
   a.Left = a.Left + 1
    a.Top = a.Top + glistN.addpixels \ 2
    pastchars = mDoc.TextParagraphLine2(item + 1, what$, ThatPara, showparagraph)
    
        If MarkedTextAny Then
        showparagraphWork = True
    If item > BlockTopline And item < BlockBottomline Then
        FillBack thisHDC, b, SelectionColor
         SetTextColor thisHDC, SelectionTextColor
         skipcolor = True
    ElseIf item = BlockTopline And item <> BlockBottomline Then

        
             If BlockEndline < BlockStartLine Then
                 If BlockEndCursor > 1 Then  ' if not leave it as is
                 b.Left = b.Left + glistN.UserControlTextWidthPixels(Mid$(glistN.list(item), 1, BlockEndCursor - 1))
                 PrintItem1X thisHDC, mDoc.TextLine2(item + 1, showparagraph, NoColor), a, mDoc.lastcolordata()
                final$ = Mid$(glistN.list(item), BlockEndCursor)
                fbypass = True
                 End If
             Else
                  If BlockStartCursor > 1 Then  ' if not leave it as is
                 b.Left = b.Left + glistN.UserControlTextWidthPixels(Mid$(glistN.list(item), 1, BlockStartCursor - 1))
                 PrintItem1X thisHDC, mDoc.TextLine2(item + 1, showparagraph, NoColor), a, mDoc.lastcolordata()
              
                 final$ = Mid$(glistN.list(item), BlockStartCursor)
                 fbypass = True
                 End If
             End If
     
             FillBack thisHDC, b, SelectionColor
             a.Left = b.Left + 1
             
         SetTextColor thisHDC, SelectionTextColor
         skipcolor = True
     ElseIf item = BlockBottomline And item <> BlockTopline Then
      
             If BlockBottomline = BlockEndline Then
                 If BlockEndCursor <= Len(glistN.list(item)) Then
                 If BlockEndCursor > 1 Then ' if not leave it as is
                 b.Right = glistN.UserControlTextWidthPixels(Mid$(glistN.list(item), 1, BlockEndCursor - 1)) + glistN.PanPosPixels + glistN.LeftMarginPixels
                 PrintItem1X thisHDC, mDoc.TextLine2(item + 1, showparagraph, NoColor), a, mDoc.lastcolordata()
                final$ = Mid$(glistN.list(item), 1, BlockEndCursor - 1)
             fbypass = False
                 Else
                   If ThatPara = mDoc.MarkParagraphID Then glistN.ExternalCursor glistN.SelStart, what$, black
                  GoTo conthere
                 End If
                 End If
                 
             Else
                  If BlockStartCursor <= Len(glistN.list(item)) Then  ' if not leave it as is
               If BlockStartCursor > 1 Then
               b.Right = glistN.UserControlTextWidthPixels(Mid$(glistN.list(item), 1, BlockStartCursor - 1)) + glistN.PanPosPixels + glistN.LeftMarginPixels
                 PrintItem1X thisHDC, mDoc.TextLine2(item + 1, showparagraph, NoColor), a, mDoc.lastcolordata()
                final$ = Mid$(glistN.list(item), 1, BlockStartCursor - 1)
               fbypass = False
                     Else
                       If ThatPara = mDoc.MarkParagraphID Then glistN.ExternalCursor glistN.SelStart, what$, black
                      GoTo conthere
                 End If
                 End If
                 
             End If
     
             FillBack thisHDC, b, SelectionColor
             a.Right = b.Right + 1
             
         SetTextColor thisHDC, SelectionTextColor
         skipcolor = True
    ElseIf BlockBottomline = item Then ' in one line only
     skipcolor = False
        If BlockEndCursor > BlockStartCursor Then
         If BlockStartCursor > 1 Then b.Left = b.Left + glistN.UserControlTextWidthPixels(Mid$(glistN.list(item), 1, BlockStartCursor - 1))
          If BlockEndCursor > 1 Then b.Right = glistN.UserControlTextWidthPixels(Mid$(glistN.list(item), 1, BlockEndCursor - 1)) + glistN.PanPosPixels + glistN.LeftMarginPixels
          If BlockStartCursor = 0 Then
     final$ = Mid$(glistN.list(item), 1, BlockEndCursor - 1)
          Else
           skipcolor = False
 final$ = Mid$(glistN.list(item), BlockStartCursor, BlockEndCursor - BlockStartCursor)
 End If

 PrintItem1X thisHDC, mDoc.TextLine2(item + 1, showparagraph, NoColor), a, mDoc.lastcolordata()
          FillBack thisHDC, b, SelectionColor
             a.Right = b.Right + 1
             a.Left = b.Left + 1
         SetTextColor thisHDC, SelectionTextColor
        ElseIf BlockEndCursor < BlockStartCursor Then
        If BlockEndCursor > 1 Then b.Left = b.Left + glistN.UserControlTextWidthPixels(Mid$(glistN.list(item), 1, BlockEndCursor - 1))
        If BlockStartCursor > 1 Then b.Right = glistN.UserControlTextWidthPixels(Mid$(glistN.list(item), 1, BlockStartCursor - 1)) + glistN.PanPosPixels + glistN.LeftMarginPixels
 If BlockEndCursor > 0 Then
 final$ = Mid$(glistN.list(item), BlockEndCursor, BlockStartCursor - BlockEndCursor)
 Else
 final$ = Mid$(glistN.list(item), 1, BlockStartCursor - 1)
 End If
 
 PrintItem1X thisHDC, mDoc.TextLine2(item + 1, showparagraph, NoColor), a, mDoc.lastcolordata()
                 FillBack thisHDC, b, SelectionColor
             a.Right = b.Right + 1
             a.Left = b.Left + 1
         SetTextColor thisHDC, SelectionTextColor
        End If
       fbypass = False
    End If
 ''  skipcolor = True
End If
    If ThatPara = mDoc.MarkParagraphID Then
            If EditDoc Then
                        ' old patch -- removed here
                      If mNoWrap And (glistN.ListIndex = item) Then
              '        glistN.ExternalCursor glistN.SelStart, what$, black
                       ElseIf (Not skipcolor) And (glistN.ListIndex = item) Then
                      If OldPar > 0 Then glistN.ExternalCursor glistN.SelStart, what$, black
                       End If
            ElseIf Not NoMark Then
            
                    FillBack thisHDC, b, 0
                     SetTextColor thisHDC, SelectionTextColor
                 
                     
            End If
    
    Else
         
    If Not skipcolor Then SetTextColor thisHDC, glistN.ForeColor
 

    End If
    If final$ <> "" Or fbypass Then

   If Not fbypass Then
 
   PrintItem thisHDC, final$, a
   Else
   PrintItem1 thisHDC, final$, a
   End If
   showparagraphWork = False
    Else
conthere:
If skipcolor Then
  PrintItem1 thisHDC, mDoc.TextLine2(item + 1, showparagraph, False), a
Else
  PrintItem1X thisHDC, mDoc.TextLine2(item + 1, showparagraph, NoColor), a, mDoc.lastcolordata()
End If
  End If
End If
SetTextColor thisHDC, oldcolor
 showparagraphonce = False

skip = True
End Sub


Public Sub Render()
' we have charpos and listindex
'glistN.NoScroll = True
'glistN.PanPos = 0
Dim selstart2 As Long
all = mDoc.DocLines
glistN.ListIndex = mDoc.FirstParagraphLine(mDoc.MarkParagraphID) + mDoc.TextParagraph2Line(mDoc.MarkParagraphID, Charpos, selstart2, mNoColor)
glistN.SelStart = selstart2

'EditDoc = EditDoc
If glistN.ListIndex < glistN.ScrollFrom Then
If glistN.ListIndex > glistN.lines Then
glistN.ScrollToSilent glistN.ListIndex - glistN.lines / 2
Else
glistN.ScrollToSilent 0
End If
ElseIf glistN.ListIndex > glistN.ScrollFrom + glistN.lines Then
glistN.ScrollToSilent glistN.ListIndex - glistN.lines
ElseIf glistN.ListIndex > glistN.lines And glistN.listcount - glistN.ListIndex < glistN.lines Then
glistN.ScrollToSilent glistN.ListIndex - glistN.lines
End If
If glistN.enabled Then glistN.ShowPan 'glistN.PrepareToShow 10
End Sub

Public Sub WrapMarkedPara()
If glistN.ListIndex >= 0 Then
mDoc.ReWritePara mDoc.MarkParagraphID, mDoc.TextParagraph(mDoc.MarkParagraphID)
End If
End Sub

Private Sub glistN_KeyDown(KeyCode As Integer, shift As Integer)
If glistN.HeadLine <> "" Then
If NoTitle Then
glistN.HeadLine = vbNullString
onelineheight = 0
glistN.HeadlineHeight = 0
ElseIf Title <> glistN.HeadLine And Not TitleStay Then
ReplaceTitle = vbNullString
End If
End If
'If KeyCode = vbKeyTab Then
'If shift = 2 Then
 '       choosenext
  '  KeyCode = 0
   ' Exit Sub
    'End If

'End If
Dim selstart2 As Long, b As Boolean, Pad$, cc As Long
Dim l1 As Long, c1 As Long
If KeyCode = 18 Then
Exit Sub
End If
If KeyCode = vbKeyF10 And shift <> 0 Then
KeyCode = 0
If mIndex >= 0 Then
   Callback.Callback mesCtrlName + ".PopUp(" + Str(mIndex) + "," + Str(MOUSEX(Callback.Left)) + "," + Str(MOUSEY(Callback.Top)) + "," + Str(2) + "," + Str(glistN.ListIndex + 1) + ")"
   Else
      Callback.Callback mesCtrlName + ".PopUp(" + Str(MOUSEX(Callback.Left)) + "," + Str(MOUSEY(Callback.Top)) + "," + Str(2) + "," + Str(glistN.ListIndex + 1) + ")"
      End If
Exit Sub
End If
If KeyCode = 16 And shift <> 0 Then
KeyCode = 0
If glistN.SelStart = 0 Then
  If mIndex >= 0 Then
   Callback.Callback mesCtrlName + ".Inform(" + Str(mIndex) + "," + Str(glistN.ListIndex + 1) + ", 1)"
   Else
      Callback.Callback mesCtrlName + ".Inform(" + Str(glistN.ListIndex + 1) + ", 1)"
      End If
Else
  If mIndex >= 0 Then
   Callback.Callback mesCtrlName + ".Inform(" + Str(mIndex) + "," + Str(glistN.ListIndex + 1) + ", " + Str(glistN.SelStart) + ")"
   Else
      Callback.Callback mesCtrlName + ".Inform(" + Str(glistN.ListIndex + 1) + ", " + Str(glistN.SelStart) + ")"
      End If
End If
Exit Sub
End If
If NoMark And Not (KeyCode <> vbKeyDown Or KeyCode <> vbKeyUp Or KeyCode <> vbKeyPageUp Or KeyCode <> vbKeyPageDown) Then KeyCode = 0: Exit Sub

If KeyCode = vbKeyLeft Or KeyCode = vbKeyUp Or KeyCode = vbKeyDown Or KeyCode = vbKeyRight Or KeyCode = vbKeyEnd Or KeyCode = vbKeyHome Or KeyCode = vbKeyPageUp Or KeyCode = vbKeyPageDown Then
'
If NoMark And KeyCode = vbKeyUp Then KeyCode = vbKeyPageUp
If NoMark And KeyCode = vbKeyDown Then KeyCode = vbKeyPageDown
ElseIf KeyCode = vbKeyX And (shift And 3) = 2 Then
MarkCut
Show
KeyCode = 0
ElseIf KeyCode = vbKeyC And (shift And 3) = 2 Then
MarkCopy
KeyCode = 0
ElseIf KeyCode = vbKeyV And (shift And 3) = 2 Then
    Pad$ = GetTextData(13)
    If Pad$ = vbNullString Then Pad$ = Clipboard.GetText(1)
    If NumberOnly Or NumberIntOnly Then
        If Not ValidNum(Pad$, False, NumberIntOnly) Then GoTo conthere
        NumberOnly = True
        If Not mNoWrap = True Then
            mNoWrap = True
            glistN.NoScroll = False
        End If
    ElseIf UsedAsTextBox Then
        Pad$ = Replace(Pad$, Chr(13), "")
        Pad$ = Replace(Pad$, Chr(10), "")
        If Not mNoWrap = True Then
            mNoWrap = True
            glistN.NoScroll = False
        End If
    End If
    If ParaSelStart = 2 And glistN.list(glistN.ListIndex) = vbNullString Then
        SelStart = SelStart - 1
    End If
    AddUndo ""
    If UsedAsTextBox Then
    Pad$ = GetNextLine((Pad$))
    If Len(Text) + Len(Pad$) > glistN.maxchar Then
        Pad$ = Myleft$(Pad$, glistN.maxchar - Len(Text))
    End If
    End If
    SelText = Pad$
    RemoveUndo Pad$
    KeyCode = 0
    ReColorBlock
ElseIf KeyCode = vbKeyA And (shift And 3) = 2 Then
glistN.MarkNext = 0
glistN.MarkALL
KeyCode = 0
ElseIf KeyCode = vbKeyY And (shift And 3) = 2 Then
' Redo
If Redopara <> -1 Then

PushUndo

undopara = Redopara
undopos = Redopos
undotext = Redotext
undomode = Redomode

b = enabled
enabled = False
SelLength = 0
If Redomode = 3 Then
SelStart = Redopos - 2
Else
SelStart = Redopos
End If
If Redomode = 0 Or Redomode = 5 Then ' now we do the opposite

If Redomode = 5 Then


PopRedo

If glistN.SelStart = 0 Then
SelLength = Len(undotext) + 1
Else
SelLength = Len(undotext)
End If
    glistN_MarkDelete True
    glistN.MarkNext = 0
PushUndo
InsertText = Redotext
undopara = Redopara
undopos = Redopos
undotext = Redotext
undomode = Redomode

Else
InsertText = Redotext

End If
ElseIf Redomode = 1 Then
If glistN.SelStart = 0 Then
SelLength = Len(Redotext) + 1
Else
SelLength = Len(Redotext)
End If
SelText = vbNullString
ElseIf Redomode = 2 Then
   keyzLineUp
ElseIf Redomode = 3 Then
glistN_SplitLine

End If

enabled = b
glistN.ShowPan
If Not PopRedo Then
Redopara = -1
Redotext = vbNullString
Redomode = 0
End If
End If
KeyCode = 0
ElseIf KeyCode = vbKeyZ And (shift And 3) = 2 Then
' 2nd version of undo system
' undopos now is selstart
If undopara <> -1 Then
' seve to redo...
PushRedo
Redopara = undopara
Redopos = undopos
Redotext = undotext
Redomode = undomode


' MOVE TO PARAGRAPH...AND CHARPOS
b = enabled
enabled = False

   SelLength = 0
   SelStart = undopos

If undomode = 0 Or undomode = 4 Then

    If glistN.SelStart = 0 Then
        SelLength = Len(undotext) + 1
    Else
        SelLength = Len(undotext)
    End If
    
    If undomode = 4 Then
    glistN_MarkDelete True
    glistN.MarkNext = 0
    PopUndo
    PushRedo
        Redopara = undopara
        Redopos = undopos
        Redotext = undotext
        Redomode = undomode

    ' now we have undomode 5
    InsertText = undotext
    Else
    SelText = vbNullString
    End If
ElseIf undomode = 3 Then
    keyzLineUp
ElseIf undomode = 2 Then
    glistN_SplitLine
Else
        InsertText = undotext
End If
enabled = b
glistN.ShowPan

End If
 If Not PopUndo Then
 ClearUndo
undopara = -1
undotext = vbNullString
undomode = 0
End If
KeyCode = 0
ElseIf KeyCode = vbKeyA And (shift And 3) = 3 Then
glistN.MarkNext = 0
BlockEndPara = mDoc.MarkParagraphID
BlockStartPara = BlockEndPara
BlockStartPos = BlockEndPos
glistN.ShowPan
KeyCode = 0

ElseIf KeyCode = vbKeyDelete Then
If HaveMarkedText Then
ClearRedo
PushUndo
glistN_MarkDelete False

KeyCode = 0
End If
ElseIf KeyCode = vbKeyBack Then
If HaveMarkedText Then
ClearRedo
PushUndo
glistN_MarkDelete False

KeyCode = 0
End If
End If
conthere:
If NoMark And EditDoc = False Then glistN.ShowMe2: Exit Sub
If KeyCode <> 0 Or shift <> 0 Then PressKey_A KeyCode, shift
End Sub

Private Sub glistN_KeyDownAfter(KeyCode As Integer, shift As Integer)
If NoMark Then Exit Sub
If HaveMarkedText Then
If shift = 0 Then
glistN.MarkNext = 0
BlockStartPara = BlockEndPara
BlockStartPos = BlockEndPos
If mIndex >= 0 Then
   Callback.Callback mesCtrlName + ".MarkNo(" + Str(mIndex) + ")"
   Else
      Callback.Callback mesCtrlName + ".MarkNo(" + ")"
      End If


ElseIf (shift And 1) = 1 Then

If KeyCode = vbKeyLeft Or KeyCode = vbKeyUp Or KeyCode = vbKeyDown Or KeyCode = vbKeyRight Or KeyCode = vbKeyEnd Or KeyCode = vbKeyHome Or KeyCode = vbKeyPageUp Or KeyCode = vbKeyPageDown Then
glistN_MarkOut
End If
End If
ElseIf (shift And 1) = 1 And glistN.MarkNext = 0 Then
If KeyCode = vbKeyLeft Or KeyCode = vbKeyUp Or KeyCode = vbKeyDown Or KeyCode = vbKeyRight Or KeyCode = vbKeyEnd Or KeyCode = vbKeyHome Or KeyCode = vbKeyPageUp Or KeyCode = vbKeyPageDown Then
glistN.MarkNext = 1
glistN_MarkIn
End If
ElseIf (shift And 1) = 1 And glistN.MarkNext > 0 Then
If KeyCode = vbKeyLeft Or KeyCode = vbKeyUp Or KeyCode = vbKeyDown Or KeyCode = vbKeyRight Or KeyCode = vbKeyEnd Or KeyCode = vbKeyHome Or KeyCode = vbKeyPageUp Or KeyCode = vbKeyPageDown Then
glistN.MarkNext = 2
glistN_MarkOut
End If
End If
End Sub

Private Sub glistN_LineDown()
Dim b$, nline As Long
mDoc.TextParagraphLine glistN.ListIndex + 1, b$, nline
mDoc.MarkParagraphID = nline

If mDoc.IsLast(mDoc.MarkParagraphID) Then Exit Sub

  
 
 If mDoc.TextParagraphLen(nline) = 0 Then
 Charpos = 1
  mDoc.RemoveEmptyParagraph nline
 mDoc.MarkParagraphID = nline
 Else
 Charpos = ParaSelStart
  mDoc.ReWritePara nline, mDoc.TextParagraph(nline) + mDoc.DeleteNextParagraph(nline)

 End If
 
  all = mDoc.DocLines
 
  ParaSelStart = Charpos
End Sub

Private Sub glistN_LineUp()
Dim olID As Long, b$ ', c$
olID = mDoc.MarkParagraphID
If ParaSelStart < 2 Then
If mDoc.ParagraphOrder(mDoc.MarkParagraphID) > 1 Then
glistN.PressKey vbKeyLeft, 0
If olID <> mDoc.MarkParagraphID Then
b$ = mDoc.DeleteNextParagraph(mDoc.MarkParagraphID)
mDoc.ReWritePara mDoc.MarkParagraphID, mDoc.TextParagraph(mDoc.MarkParagraphID) + b$
 all = mDoc.DocLines
ClearRedo
PushUndo
undotext = vbCrLf
undopara = mDoc.MarkParagraphID
undopos = SelStart
undomode = 2
'End If
Render
End If
End If
Else
glistN.PressKey vbKeyLeft, 0
End If
all = mDoc.DocLines

End Sub

Private Sub keyzLineUp()
Dim olID As Long, b$ ', c$
olID = mDoc.MarkParagraphID
If ParaSelStart < 2 Then
If mDoc.ParagraphOrder(mDoc.MarkParagraphID) > 1 Then
glistN.PressKey vbKeyLeft, 0
If olID <> mDoc.MarkParagraphID Then
b$ = mDoc.DeleteNextParagraph(mDoc.MarkParagraphID)
mDoc.ReWritePara mDoc.MarkParagraphID, mDoc.TextParagraph(mDoc.MarkParagraphID) + b$
Render
End If
End If
Else
glistN.PressKey vbKeyLeft, 0
End If
all = mDoc.DocLines
End Sub

Public Sub MarkCut()
MarkCopy
PushUndo
glistN_MarkDelete False

End Sub
Private Sub FillBlock()
Dim order1 As Long, order2 As Long, a$, b$, i As Long, nn As Long
' TAKE FIRST VBCRLF IF FIRST LINE =""
On Error GoTo fbl

 Set UndoDoc = New Document
 UndoDoc.CrTail = False
    If BlockStartPara = BlockEndPara Then
        b$ = mDoc.TextParagraph(BlockStartPara)
        
        UndoDoc.CrTail = False
        If b$ = vbNullString Then
        Else
        If BlockStartPos < BlockEndPos Then
           '' UndoDoc.textDoc = Mid$(b$, BlockStartPos, BlockEndPos - BlockStartPos)
            UndoDoc.textParagraphPlusColor Mid$(b$, BlockStartPos, BlockEndPos - BlockStartPos), mDoc.Paracolordata(BlockStartPara), BlockStartPos - 1
            If BlockEndPos > Len(b$) + 1 Then UndoDoc.CrTail = True
        Else
          '' UndoDoc.textDoc = Mid$(b$, BlockEndPos, BlockStartPos - BlockEndPos)
            UndoDoc.textParagraphPlusColor Mid$(b$, BlockEndPos, BlockStartPos - BlockEndPos), mDoc.Paracolordata(BlockStartPara), BlockEndPos - 1
            If BlockStartPos > Len(b$) + 1 Then UndoDoc.CrTail = True
        End If
        End If
    Else
        order1 = mDoc.ParagraphOrder(BlockStartPara)
        order2 = mDoc.ParagraphOrder(BlockEndPara)
        If order2 > order1 Then '  normal
            a$ = mDoc.TextParagraph(BlockStartPara)
            UndoDoc.LfLead = False
         If BlockStartPos < 1 Then
               UndoDoc.AppendParagraphPlusColor a$, mDoc.Paracolordata(BlockStartPara)
               '' UndoDoc.AppendParagraph a$
            Else
            If Len(a$) + 1 < BlockStartPos Then
                UndoDoc.LfLead = True
                UndoDoc.AppendParagraph ""  '' no color
               Else
            
                ''UndoDoc.AppendParagraph Mid$(a$, BlockStartPos)
                UndoDoc.AppendParagraphPlusColor Mid$(a$, BlockStartPos), mDoc.Paracolordata(BlockStartPara), BlockStartPos - 1
                End If
            End If
            UndoDoc.MarkParagraphID = 1
            nn = BlockStartPara
            order2 = order2 - 1
            If order2 > order1 Then
                For i = order1 + 1 To order2
               ' UndoDoc.MarkParagraphID = UndoDoc.InsertAfterParagraph(UndoDoc.MarkParagraphID, mDoc.TextNextParagraph(nn))
                UndoDoc.MarkParagraphID = UndoDoc.InsertAfterParagraphPlusColor(UndoDoc.MarkParagraphID, mDoc.TextNextParagraph(nn), mDoc.Paracolordata(nn))
                Next i
            End If
                b$ = mDoc.TextParagraph(BlockEndPara)
                UndoDoc.CrTail = False
                
               If BlockEndPos > 0 Then
               ''UndoDoc.AppendParagraph MyLeft$(b$, BlockEndPos - 1) 'maybe is empty
               UndoDoc.AppendParagraphPlusColor Myleft$(b$, BlockEndPos - 1), mDoc.Paracolordata(BlockEndPara)
               Else
               UndoDoc.CrTail = True
               End If
        Else
            a$ = mDoc.TextParagraph(BlockEndPara)
        '   If a$ = VbNullString Then UndoDoc.AppendParagraph ""
         UndoDoc.LfLead = False
            If BlockEndPos < 1 Then
        
              UndoDoc.AppendParagraphPlusColor a$, mDoc.Paracolordata(BlockEndPara)
               ' UndoDoc.AppendParagraph a$
                
            Else
                 If Len(a$) + 1 < BlockEndPos Then
                UndoDoc.LfLead = True
                UndoDoc.AppendParagraph ""
            Else
                ' UndoDoc.AppendParagraph Mid$(a$, BlockEndPos)
                If BlockEndPos >= 1 Then
                  UndoDoc.AppendParagraphPlusColor Mid$(a$, BlockEndPos), mDoc.Paracolordata(BlockEndPara), BlockEndPos - 1
                  Else
                  UndoDoc.AppendParagraphPlusColor Mid$(a$, BlockEndPos), mDoc.Paracolordata(BlockEndPara)
                  End If
                End If
            End If
            UndoDoc.MarkParagraphID = 1
             nn = BlockEndPara
            order1 = order1 - 1
            If order1 > order2 Then
                For i = order2 + 1 To order1
                ''UndoDoc.MarkParagraphID = UndoDoc.InsertAfterParagraph(UndoDoc.MarkParagraphID, mDoc.TextNextParagraph(nn))
                UndoDoc.MarkParagraphID = UndoDoc.InsertAfterParagraphPlusColor(UndoDoc.MarkParagraphID, mDoc.TextNextParagraph(nn), mDoc.Paracolordata(nn))
                Next i
            End If
                b$ = mDoc.TextParagraph(BlockStartPara)
                If BlockStartPos < 1 Then BlockStartPos = 1
                  'UndoDoc.AppendParagraph MyLeft$(b$, BlockStartPos - 1) 'maybe is empty
                  UndoDoc.AppendParagraphPlusColor Myleft$(b$, BlockStartPos - 1), mDoc.Paracolordata(BlockStartPara)
        
        End If
End If
fbl:
End Sub

Public Sub MarkCopy()
If Not NoColor Then ColorBlockOnly
If HaveMarkedText Then
FillBlock
Dim pp1 As String, pp2 As String
pp1 = UndoDoc.textDoc

If Not mNoColor Then pp2 = SelHtmlText
Clipboard.Clear  ' always

blockKeyboard = True
MyDoEvents
blockKeyboard = False
 On Error Resume Next
 ProcTask2 basestack1
'mywait basestack1, 10

If Not mNoColor Then SimpleHtmlData pp2
 SetTextData 13, pp1

End If
End Sub
Private Function SetTextDataLong( _
        ByVal lFormatId As Long, _
         dLong As Long _
    ) As Boolean
    ' use strptr and lenb
    Dim hMem As Long, lPtr As Long
 ''   Dim checkme As Long
    Dim lSize As Long
        lSize = 4
    hMem = GlobalAlloc(0, lSize)
If (hMem > 0) Then
        lPtr = GlobalLock(hMem)
        CopyMemory ByVal lPtr, dLong, lSize
       '' CopyMemory checkme, ByVal lPtr, lSize
     
        GlobalUnlock hMem
       If (OpenClipboard(0) <> 0) Then
     SetClipboardData lFormatId, hMem
      CloseClipboard
       End If
          
    End If
    

End Function
Private Function SetTextData( _
        ByVal lFormatId As Long, _
        ByVal sText As String _
    ) As Boolean
    If lFormatId = 0 Then Exit Function
    Dim hMem As Long, lPtr As Long
    Dim lSize As Long
        lSize = LenB(sText)
    hMem = GlobalAlloc(0, lSize + 2)
If (hMem > 0) Then
        lPtr = GlobalLock(hMem)
        CopyMemory ByVal lPtr, ByVal StrPtr(sText), lSize + 1
        GlobalUnlock hMem
       If (OpenClipboard(0) <> 0) Then
     SetClipboardData lFormatId, hMem
      CloseClipboard
      Else
      GlobalFree hMem
       End If
    End If
End Function

Private Sub glistN_MarkDelete(preservecursor As Boolean)
Dim order1 As Long, order2 As Long, a$, b$, i As Long
Dim oldid As Long, OLDPOS As Long
oldid = mDoc.MarkParagraphID
OLDPOS = Charpos
 If HaveMarkedText Then
 Set UndoDoc = New Document
    If BlockStartPara = BlockEndPara Then
        b$ = mDoc.TextParagraph(BlockStartPara)
        If BlockStartPos < BlockEndPos Then
            UndoDoc.textDoc = Mid$(b$, BlockStartPos, BlockEndPos - BlockStartPos)
            b$ = Mid$(b$, 1, BlockStartPos - 1) + Mid$(b$, BlockEndPos)
                        If OLDPOS > BlockStartPos And oldid = BlockStartPara Then
            OLDPOS = OLDPOS - (BlockEndPos - BlockStartPos)
            End If
            Charpos = BlockStartPos
        Else
           UndoDoc.textDoc = Mid$(b$, BlockEndPos, BlockStartPos - BlockEndPos)
            b$ = Myleft$(b$, BlockEndPos - 1) + Mid$(b$, BlockStartPos)
            If OLDPOS > BlockEndPos And oldid = BlockStartPara Then
            OLDPOS = OLDPOS - (BlockStartPos - BlockEndPos)
            End If
            Charpos = BlockEndPos
        End If
        mDoc.ReWritePara BlockStartPara, b$
    Else
        order1 = mDoc.ParagraphOrder(BlockStartPara)
        order2 = mDoc.ParagraphOrder(BlockEndPara)
  
        If order2 > order1 Then '  normal
            UndoDoc.AppendParagraph "" ' start paragraph no 1
            UndoDoc.MarkParagraphID = 1
        
            b$ = mDoc.TextParagraph(BlockEndPara)
            mDoc.RemoveDocParaIndex BlockEndPara
            If BlockEndPos < 1 Then
            UndoDoc.AppendParagraph ""
            b$ = vbNullString
            Else
            UndoDoc.AppendParagraph Myleft$(b$, BlockEndPos - 1) 'maybe is empty
            b$ = Mid$(b$, BlockEndPos)
            End If
            
            
            order2 = order2 - 1
            If order2 > order1 Then
                For i = order1 + 1 To order2
                UndoDoc.MarkParagraphID = UndoDoc.InsertAfterParagraph(UndoDoc.MarkParagraphID, mDoc.DeleteNextParagraph(BlockStartPara))
                    
                Next i
            End If
            a$ = mDoc.TextParagraph(BlockStartPara)
            UndoDoc.ReWritePara 1, a$, True
            If BlockStartPos = 1 Then
                mDoc.ReWritePara BlockStartPara, b$
                UndoDoc.ReWritePara 1, a$, True
            Else
            UndoDoc.ReWritePara 1, Mid$(a$, BlockStartPos), True
                mDoc.ReWritePara BlockStartPara, Myleft$(a$, BlockStartPos - 1) + b$
            End If
            mDoc.MarkParagraphID = BlockStartPara
            Charpos = BlockStartPos
        Else
            UndoDoc.AppendParagraph "" ' start paragraph no 1
            UndoDoc.MarkParagraphID = 1
             b$ = mDoc.TextParagraph(BlockStartPara)
            mDoc.RemoveDocParaIndex BlockStartPara
             UndoDoc.AppendParagraph Myleft$(b$, BlockStartPos - 1) 'maybe is empty
            b$ = Mid$(b$, BlockStartPos)
            order1 = order1 - 1
            If order1 > order2 Then
                For i = order2 + 1 To order1
                    
                    UndoDoc.MarkParagraphID = UndoDoc.InsertAfterParagraph(UndoDoc.MarkParagraphID, mDoc.DeleteNextParagraph(BlockEndPara))
               
                Next i
            End If
            a$ = mDoc.TextParagraph(BlockEndPara)
            
            If BlockEndPos = 1 Then
                mDoc.ReWritePara BlockEndPara, b$
                UndoDoc.ReWritePara 1, a$
            Else
            UndoDoc.ReWritePara 1, Mid$(a$, BlockEndPos)
                mDoc.ReWritePara BlockEndPara, Myleft$(a$, BlockEndPos - 1) + b$
            End If
            mDoc.MarkParagraphID = BlockEndPara
            
            Charpos = BlockEndPos
        
        
        End If

End If
all = mDoc.DocLines
If Not preservecursor Then
undopara = mDoc.MarkParagraphID
undopos = SelStart
undotext = UndoDoc.textDoc
undomode = 1 ' insert text at position changed to 1
End If
Set UndoDoc = New Document


glistN.MarkNext = 0
BlockStartPara = BlockEndPara
BlockStartPos = BlockEndPos
If preservecursor Then
If mDoc.ParagraphOrder(oldid) > 0 Then

mDoc.MarkParagraphID = oldid
Charpos = OLDPOS
End If
End If
Render
If mIndex >= 0 Then
   Callback.Callback mesCtrlName + ".MarkNo(" + Str(mIndex) + ")"
   Else
      Callback.Callback mesCtrlName + ".MarkNo(" + ")"
      End If
End If

End Sub

'
Private Sub glistN_MarkDestroy()
' destroy or open to change
If Not ClickInsideMarkedText Then
BlockStartPara = BlockEndPara
BlockStartPos = BlockEndPos
  If mIndex >= 0 Then
   Callback.Callback mesCtrlName + ".MarkNo(" + Str(mIndex) + ")"
   Else
      Callback.Callback mesCtrlName + ".MarkNo(" + ")"
      End If
Else
glistN.MarkNext = 1
' we have to raise event now
End If
End Sub

Private Sub glistN_MarkDestroyAny()
' destroy always
BlockStartPara = BlockEndPara
BlockStartPos = BlockEndPos
glistN.MarkNext = 0
  If mIndex >= 0 Then
   Callback.Callback mesCtrlName + ".MarkNo(" + Str(mIndex) + ")"
   Else
      Callback.Callback mesCtrlName + ".MarkNo(" + ")"
      End If
End Sub

Private Sub glistN_MarkIn()
If Not glistN.EditFlag Then glistN.MarkNext = 0: Exit Sub
BlockStartPara = mDoc.MarkParagraphID
BlockStartPos = ParaSelStart
'If glistN.SelStart > 1 Then
BlockStartCursor = glistN.SelStart '- 1
'Else
'BlockStartCursor = 1
'End If
BlockEndCursor = BlockStartCursor + 1

BlockStartLine = glistN.ListIndex
BlockEndline = BlockStartLine
BlockEndPara = BlockStartPara
BlockEndPos = BlockStartPos
End Sub
Function HaveMarkedText() As Boolean
If BlockEndPos < 1 Then BlockEndPos = 1
If glistN.MarkNext = 0 Then
Else
If BlockStartPara <> BlockEndPara Then
HaveMarkedText = True
ElseIf BlockStartPos <> BlockEndPos Then
HaveMarkedText = True
End If
End If
End Function
Function MarkedTextAny() As Boolean
If BlockStartPara <> BlockEndPara Then
MarkedTextAny = True
ElseIf BlockStartPos <> BlockEndPos Then
MarkedTextAny = True
End If
End Function


Function ClickInsideMarkedText() As Boolean
' we need that for drag and drop, copy or move
' it is simple
' we now the current line and selstart of glistN
If MarkedTextAny Then
If BlockTopline <> BlockBottomline Then
If glistN.ListIndex = BlockTopline Then
    If BlockEndline < BlockStartLine Then
    If glistN.SelStart >= BlockEndCursor Then ClickInsideMarkedText = True
    Else
    If glistN.SelStart >= BlockStartCursor Then ClickInsideMarkedText = True
    End If
ElseIf glistN.ListIndex = BlockBottomline Then
    If BlockEndline < BlockTopline Then
    If glistN.SelStart <= BlockStartCursor Then ClickInsideMarkedText = True
    Else
    If glistN.SelStart <= BlockEndCursor Then ClickInsideMarkedText = True
    End If
ElseIf glistN.ListIndex < BlockTopline Or glistN.ListIndex > BlockBottomline Then
' FALSE
Else
    ClickInsideMarkedText = True
End If
ElseIf BlockTopline = glistN.ListIndex Then
If BlockEndCursor < BlockStartCursor Then
If glistN.SelStart >= BlockEndCursor And glistN.SelStart <= BlockStartCursor Then ClickInsideMarkedText = True
Else
If glistN.SelStart >= BlockStartCursor And glistN.SelStart <= BlockEndCursor Then ClickInsideMarkedText = True
End If

End If
End If
End Function
Sub RelocateMarkedText()
' when we resize glist, need to calculate the position of marked text
' we use a second set of variables
'  BlockStartPara As Long, BlockStartPos As Long
' BlockEndPara As Long, BlockEndPos As Long
'
BlockStartLine = mDoc.FirstParagraphLine(BlockStartPara) + mDoc.TextParagraph2Line(BlockStartPara, BlockStartPos, BlockStartCursor)
BlockEndline = mDoc.FirstParagraphLine(BlockEndPara) + mDoc.TextParagraph2Line(BlockEndPara, BlockEndPos, BlockEndCursor)
If BlockEndline < BlockStartLine Then
    BlockTopline = BlockEndline
    BlockBottomline = BlockStartLine
Else
    BlockTopline = BlockStartLine
    BlockBottomline = BlockEndline
End If
End Sub
Private Sub glistN_MarkOut()
'
BlockEndPara = mDoc.MarkParagraphID
BlockEndPos = ParaSelStart
BlockEndline = glistN.ListIndex
BlockEndCursor = glistN.SelStart
If BlockEndline < BlockStartLine Then
    BlockTopline = BlockEndline
    BlockBottomline = BlockStartLine
Else
    BlockTopline = BlockStartLine
    BlockBottomline = BlockEndline
End If
'
If HaveMarkedText Then
  If mIndex >= 0 Then
   Callback.Callback mesCtrlName + ".MarkOut(" + Str(mIndex) + ")"
   Else
      Callback.Callback mesCtrlName + ".MarkOut(" + ")"
      End If
Else
If mIndex >= 0 Then
   Callback.Callback mesCtrlName + ".MarkNo(" + Str(mIndex) + ")"
   Else
      Callback.Callback mesCtrlName + ".MarkNo(" + ")"
      End If
End If
End Sub

Private Sub glistN_ReadListItem(item As Long, content As String)
If item >= 0 Then

content = mDoc.TextLine2(item + 1, showparagraphWork And showparagraph)

End If
End Sub



'End Sub

Private Sub glistN_ScrollSelected(item As Long, y As Long)
If NoMark Then Exit Sub
Dim what$, ThatPara As Long
   mDoc.TextParagraphLine item, what$, ThatPara
   mDoc.MarkParagraphID = ThatPara
End Sub

Private Sub glistN_Selected(item As Long)
  If undomode = 1 And undotext <> "" Then PushUndo
If NoMark Then Exit Sub
If mEditDoc <> glistN.EditFlag Then EditDoc = EditDoc
Dim what$, ThatPara As Long
   mDoc.TextParagraphLine2 item, what$, ThatPara, showparagraphWork And showparagraph
   mDoc.MarkParagraphID = ThatPara
End Sub


Private Sub glistN_Selected2(item As Long)
If undomode = 1 And undotext <> "" Then PushUndo
If ClickInsideMarkedText Then
' start drag
glistN.MarkNext = 4

glistN.DragNow
End If
End Sub

Private Sub glistN_ShowExternalCursor()
glistN.PrepareToShow 5
End Sub



Private Sub glistN_SpinnerValue(ThatValue As Long)
'

End Sub

Private Sub glistN_SplitLine()
'
Dim b$, dummy As Long, a As Long
If NumberOnly Or NumberIntOnly Or UsedAsTextBox Then Exit Sub
If glistN.ListIndex >= 0 Then
    b$ = mDoc.TextParagraph(mDoc.MarkParagraphID)
If Charpos = 1 And b$ <> "" Then
    dummy = mDoc.InsertBeforeParagraph(mDoc.MarkParagraphID, "")
        mDoc.ColorThis (dummy)
     all = mDoc.DocLines
    mDoc.MarkParagraphID = dummy
    SetRowColumn glistN.ListIndex + 2, 0

    
  ''
   
ElseIf ParaSelStart = 1 Then
    mDoc.MarkParagraphID = mDoc.InsertAfterParagraph(mDoc.MarkParagraphID, "")
    all = mDoc.DocLines
    ParaSelStart = 1

ElseIf ParaSelStart > Len(b$) Then

    mDoc.MarkParagraphID = mDoc.InsertAfterParagraph(mDoc.MarkParagraphID, "")
    
      all = mDoc.DocLines
    ParaSelStart = Len(b$)

Else  ' ANYWHERE

dummy = ParaSelStart

    mDoc.ReWritePara mDoc.MarkParagraphID, Myleft$(b$, ParaSelStart - 1), False ' write and format
    
    mDoc.MarkParagraphID = mDoc.InsertAfterParagraph(mDoc.MarkParagraphID, Mid$(b$, dummy))
    mDoc.ColorThis (mDoc.MarkParagraphID)
    all = mDoc.DocLines
    ParaSelStart = 1

End If
End If
End Sub


Private Sub glistN_SyncKeyboard(item As Integer)
If NoMark Then item = 0
If blockKeyboard Then item = 0
If item > 32 And item <> 127 Then GetUndoNext = True
End Sub
Private Sub glistN_RegisterGlist(this As gList)
On Error Resume Next
Set LastGlist = this
If Err.Number > 0 Then this.NoWheel = True
End Sub
Private Sub glistN_UnregisterGlist()
On Error Resume Next
If glistN.TabStopSoft Then Callback.LastActive = ctrlName
Set LastGlist = Nothing
If Err.Number > 0 Then glistN.NoWheel = True
End Sub

Private Sub glistN_WordMarked(ThisWord As String)
  If mIndex >= 0 Then
   Callback.Callback mesCtrlName + ".Word(" + Str(mIndex) + ",{" + ThisWord + "})"
   Else
      Callback.Callback mesCtrlName + ".Word({" + ThisWord + "})"
      End If
End Sub

Private Sub mDoc_BreakLine(data As String, datanext As String)
 ' Nowrap = True mean no Wrap
 Dim data1 As String, datanext1 As String
 If nowrap Then
    datanext = data
    data = vbNullString
 Else
    If showparagraph Then
         data1 = Replace(Replace(data, " ", ChrW(&HB7)), ChrW(&H2007), ChrW(&H2423))
        
        glistN.BreakLine data1, datanext1, , ChrW(&HB7)
        If data1 <> "" Then
        
        datanext = Myleft$(data, Len(datanext1))
        data = Right$(data, Len(data1))
        Else
            datanext = data
             data = vbNullString
        End If
      
    Else
        glistN.BreakLine data, datanext
    End If
End If

End Sub
Private Sub makebase(basecolor As Long)
ReDim col(1)
col(0) = basecolor
col(1) = 1

End Sub
Private Sub addone(ByVal thispos As Long, ByVal thiscolor As Long)
Dim k As Long
k = UBound(col())
If VarType(col(0)) = 0 Then
makebase 14
If thispos <> 1 Then
k = UBound(col())
Else
col(0) = thiscolor
Exit Sub
End If
End If
' LOOK THIS SECOND TIME
If k > 1 Then If col(k - 1) = thiscolor Then Exit Sub
ReDim Preserve col(k + 2)
col(k + 1) = thiscolor
col(k + 2) = thispos


End Sub
Private Sub ColorizeExpressions(ByVal a$, k As Long, pos2 As Long, feedthis As Long)
Dim drop$, pos1 As Long, kind As Long
Dim lastcol As Long
again:
If a$ = vbNullString Then Exit Sub
kind = IsLabelOnly(a$, drop$)
If kind = 100 Then
    If pos2 > 0 Then
            addone pos2, 14
        Else
            addone 1, 14
        End If
         pos2 = k - Len(a$) + 1
         
    kind = 0
    GoTo again
    
    End If
If kind = 0 Then drop$ = vbNullString
If kind > 0 Then
    If IsmineHere2(drop$) Then
    lastcol = 11
    If pos2 > 0 Then
       addone pos2, 11
    Else
       addone k - Len(a$) - Len(drop$) + 1, 11
       End If
    ElseIf IsmineHere(drop$) Then  ' FALL TO MAIN VOC
    lastcol = 11
    If pos2 > 0 Then
       addone pos2, 11
    Else
       addone k - Len(a$) - Len(drop$) + 1, 11
       End If
        '' for the end
   Else
   If kind = 10 Then lastcol = 14 Else lastcol = 10
   If pos2 > 0 Then
       addone pos2, lastcol
   Else
       addone k - Len(a$) - Len(drop$) + 1, lastcol
      
       End If
  End If
  pos2 = k - Len(a$) + 1
  If kind > 3 Then
  Do
  pos1 = 1
  drop$ = aheadstatus(a$, False, pos1)
  If pos1 > 1 Then
  ColorizeExpressions Mid$(a$, 1, pos1 - 1), k - Len(a$) + pos1 - 1, pos2, feedthis
  
  If feedthis = 1 Then Exit Sub
  ' check next paragraph for symbols as starting position, if not feedthis
 If feedthis > 0 And pos1 >= Len(a$) Then Exit Sub
  feedthis = 0
   a$ = Mid$(a$, pos1)
   End If
   If FastSymbol(a$, ",") Then
     addone pos2, 14
    pos2 = k - Len(a$) + 1
   ElseIf MaybeIsSymbol(a$, OtherSymbols, , True) Then
     addone pos2, 14
    pos2 = k - Len(a$) + 1
   Else
   Exit Do
   End If
   Loop
    If FastSymbol(a$, ")") Then
  addone pos2, lastcol
    pos2 = k - Len(a$) + 1
  End If
  End If

GoTo again
ElseIf IsSymbol(a$, ",") Then
addone pos2, 14
pos2 = k - Len(a$) + 1
    GoTo again
ElseIf MaybeIsSymbol(a$, OtherSymbols, , True) Then
addone pos2, 14
pos2 = k - Len(a$) + 1
    GoTo again
 ElseIf MaybeIsSymbol(a$, LineComment2) Then
drop$ = "  "
If pos2 > 0 Then
 addone pos2, 7

Else
addone 1, 7
End If
feedthis = 1
 Exit Sub
ElseIf MaybeIsSymbol2(a$, ComSymbolsWidth, CommentSymbols) Then
drop$ = "  "
If pos2 > 0 Then
 addone pos2, 7

Else
addone 1, 7
End If
feedthis = 1
  Exit Sub
ElseIf FastSymbol(a$, MultiLineComment1, , Len(MultiLineComment1)) Then
addone pos2, 15

drop$ = blockString(a$)
If drop$ <> "" Or (drop$ = vbNullString And Myleft$(a$, 1) = mMultiLineComment2) Then
feedthis = 0
If Not MaybeIsSymbol(a$, mMultiLineComment2, , True) Then feedthis = 15
Else
feedthis = 15
End If
drop$ = vbNullString
pos2 = k - Len(a$) + 1
If feedthis = 15 Then Exit Sub
    GoTo again

ElseIf MaybeIsSymbol(a$, Chr(34)) Then

If Not ISSTRINGA(a$, drop$) Then
a$ = vbNullString
addone pos2, 10
Else
addone pos2, 15
End If
drop$ = vbNullString
pos2 = k - Len(a$) + 1
    GoTo again

Else
addone pos2, 14
a$ = Mid$(a$, 2)
    pos2 = k - Len(a$) + 1
    GoTo again

 End If
If pos2 > 0 Then addone pos2, 14


End Sub
Private Function blockString(s$) As String
Dim i As Long, j As Long, c As Long
Dim a1 As Boolean

If s$ = vbNullString Then Exit Function
If mMultiLineComment2 <> "}" Then
i = InStr(s$, mMultiLineComment2)
If i > 0 Then blockString = Mid$(s$, 1, i - 1): s$ = Mid$(s$, i)
Exit Function
Else

c = Len(s$)
a1 = True
i = 1
Do
Select Case Asc(Mid$(s$, i, 1))
Case 34
Do While i < c
i = i + 1
If Asc(Mid$(s$, i, 1)) = 34 Then If Asc(Mid$(s$, i - 1, 1)) <> 92 Then Exit Do
Loop
Case 123
j = j - 1
Case 125
j = j + 1: If j = 1 Then Exit Do
End Select
i = i + 1
Loop Until i > c
If j = 1 Then
blockString = Myleft$(s$, i - 1)
s$ = Mid$(s$, i)
Else
blockString = s$
s$ = vbNullString
End If
If Right$(blockString, 1) = " " Then
i = Len(blockString) - Len(RTrim(blockString))
If i > 0 Then blockString = ReplaceStr(Chr$(10) + Space(i), Chr$(10), blockString)
End If
End If
End Function
Private Function IsLabelDot(where$, a$, r$) As Long ' ok
' for left side...no &

Dim rr&, one As Boolean, c$, firstdot$, gr As Boolean
r$ = vbNullString
If a$ = vbNullString Then IsLabelDot = 0: Exit Function

a$ = NLtrim$(a$)
    Do While Len(a$) > 0
    c$ = Myleft$(a$, 1)
    If AscW(c$) < 256 Then
        Select Case AscW(c$)
        Case 46 '"."
            If one Then
            Exit Do
            ElseIf r$ <> "" And Len(a$) > 1 Then
            If Mid$(a$, 2, 2) = ". " Or Mid$(a$, 2, 1) = " " Then Exit Do
            r$ = r$ & Myleft$(a$, 1)
            a$ = Mid$(a$, 2)
            rr& = 1
            Else
            firstdot$ = firstdot$ + "."
            a$ = Mid$(a$, 2)
            End If
       Case 64, 91 To 94, 123 To 126
        Exit Do

        Case 48 To 57
           If one Then
            If firstdot$ <> "" Then a$ = firstdot$ + a$
            Exit Do
            ElseIf r$ <> "" Then
            r$ = r$ & Myleft$(a$, 1)
            a$ = Mid$(a$, 2)
            rr& = 1
            Else
            Exit Do
            End If
        Case Is < 0, Is > 64
            If one Then
            Exit Do
            Else
            r$ = r$ & Myleft$(a$, 1)
            a$ = Mid$(a$, 2)
            rr& = 1
            End If
        Case 36 ' "$"
            If one Then Exit Do
            If r$ <> "" Then
            one = True
            rr& = 1
            r$ = r$ & Myleft$(a$, 1)
            a$ = Mid$(a$, 2)
            Else
            Exit Do
            End If
        Case 37 ' "%"
            If one Then Exit Do
            If r$ <> "" Then
            one = True
            rr& = 1
            r$ = r$ & Myleft$(a$, 1)
            a$ = Mid$(a$, 2)
            Else
            Exit Do
            End If
        Case 40 ' "("
            If r$ <> "" Then
                                       Select Case rr&
                                       Case 1, 3, 4
                                       rr& = 5
                                       Case Else
                                       Exit Do
                                       End Select
                                       r$ = r$ & Myleft$(a$, 1)
                                       a$ = Mid$(a$, 2)
                                   Exit Do
                            
              '            End If
               Else
                        Exit Do
            
            End If
        Case Else
        Exit Do
        End Select
        Else
            If one Then
            Exit Do
            Else
            gr = True
            r$ = r$ & Myleft$(a$, 1)
            a$ = Mid$(a$, 2)
            rr& = 1 'is an identifier or floating point variable
            End If
        End If

    Loop
       r$ = firstdot$ + myUcase(r$, gr)
    IsLabelDot = rr&
   'a$ = LTrim(a$)

End Function
Private Function IsLabelOnly(a$, r$) As Long 'ok

Dim rr&, one As Boolean, c$, dot&, Extra&, ExtraYes As Boolean, use14 As Boolean
r$ = vbNullString
If a$ = vbNullString Then IsLabelOnly = 0: Exit Function
a$ = NLtrim$(a$)
again1:
    Do While Len(a$) > 0
     c$ = Myleft$(a$, 1) 'ANYCHAR HERE
    If OtherSymbols <> "" Then
    If InStr(OtherSymbols, c$) > 0 Then a$ = Mid$(a$, 2): rr& = 10: Extra& = 0: Exit Do
    End If
    If ExtraFront <> "" And Not use14 Then
    If ExtraYes Then
    If IsmineHere3(r$) Then
    use14 = True
    End If
    ElseIf r$ = "" Then
    If InStr(ExtraFront, c$) > 0 Then
        r$ = c$
        a$ = Mid$(a$, 2)
        one = False
        rr& = 1
        ExtraYes = True
        GoTo again1
    End If
    End If
    End If
    If AscW(c$) < 256 Then
        Select Case AscW(c$)
        Case 46 '"."
            If one Then
                Exit Do
            ElseIf r$ <> "" Then
                r$ = r$ & Myleft$(a$, 1)
                a$ = Mid$(a$, 2)
           ElseIf Not Mid$(a$, 2, 1) Like "[0-9]" Then
                       If r$ <> "" Then
                           r$ = r$ & Myleft$(a$, 1)
                          rr& = 1
                                      
                        Else
                            
                        dot& = dot& + 1
                    
                        End If
                        If Mid$(a$, 2, 1) Like "[eE]" Then
                            r$ = r$ & Mid$(a$, 2, 1)
                             a$ = Mid$(a$, 3)
                        Else
                             a$ = Mid$(a$, 2)
                        End If
            Else
                If r$ = vbNullString And dot& > 0 Then
                    r$ = String$(dot& + 1, ".")
                    a$ = Mid$(a$, 2)
                   IsLabelOnly = 1
                Else
                    If MaybeIsSymbolNoSpace(Mid$(a$, 2, 1), "1234567890") Then
                        FastSymbol a$, "."
                        While MaybeIsSymbolNoSpace(a$, "1234567890", True)
                        Wend
                        If MaybeIsSymbolNoSpace(Mid$(a$, 3, 1), "Ee") Then
                            a$ = Mid$(a$, 4)
                            MaybeIsSymbolNoSpace a$, "+-", True
                            MaybeIsSymbolNoSpace a$, "123456789", True
                            While MaybeIsSymbolNoSpace(a$, "1234567890", True)
                            Wend
                            If MaybeIsSymbolNoSpace(a$, ".") Then
                                a$ = ""
                            End If
                        End If
                        If MaybeIsSymbolNoSpace(a$, ".") Then
                    'a$ = ""
                            IsLabelOnly = 1
                        Else
                            IsLabelOnly = 100
                        End If
                        Exit Function
                    End If
                    IsLabelOnly = 0
                End If
                Exit Function
            End If
     Case 35, 64, 91 To 94, 123 To 126 '"\","^", "{" To "~"
     
Exit Do
        
        Case 48 To 57, 95 '"0" To "9", "_"
       
           If one Then
           
            Exit Do
            ElseIf r$ <> "" Then
            r$ = r$ & Myleft$(a$, 1)
            a$ = Mid$(a$, 2)
               rr& = 1 'is an identifier or floating point variable
            ElseIf Mid$(a$ + "__", 2, 2) Like "[Xx][0-9A-Fa-f]" Then
             r$ = r$ & Myleft$(a$, 3)
            a$ = Mid$(a$, 4)
               rr& = 1
            Extra& = 9
            Else
            If dot& > 0 Then
            a$ = "." + a$: dot& = 0
            ElseIf Mid$(a$, 2, 1) = "." Then
            a$ = Mid$(a$, 3)
checkexp:
              While MaybeIsSymbolNoSpace(a$, "1234567890", True)
              Wend

              If MaybeIsSymbolNoSpace(a$, "Ee", True) Then
                  MaybeIsSymbolNoSpace a$, "+-", True
                  If MaybeIsSymbolNoSpace(a$, "+-", True) Then
                  IsLabelOnly = 1
                  Exit Function
                  End If
                  MaybeIsSymbolNoSpace a$, "123456789", True
                  While MaybeIsSymbolNoSpace(a$, "1234567890", True)
                  Wend
                  If MaybeIsSymbolNoSpace(a$, ".") Then
                  IsLabelOnly = 1
                  a$ = ""
                  Exit Function
                  End If
              Else
              While MaybeIsSymbolNoSpace(a$, "1234567890", True)
              Wend
              End If
            If MaybeIsSymbolNoSpace(a$, ".") Then
             
              IsLabelOnly = 1
              Else
              IsLabelOnly = 100
              End If
              
              Exit Function
            ElseIf MaybeIsSymbolNoSpace(a$, "1234567890", True) Then
              While MaybeIsSymbolNoSpace(a$, "1234567890", True)
              Wend
                  If MaybeIsSymbolNoSpace(a$, ".", True) Then
                                
                    GoTo checkexp
                  End If
                IsLabelOnly = 100
                Exit Function
            End If
            Exit Do
            End If
        Case Is < 0, Is > 64 ' >=A and negative

            If one Then
            Exit Do
            Else
  If Extra& > 0 Then
  If Len(r$) = 10 Then Exit Do
  If Not c$ Like "[0-9a-fA-F]" Then Exit Do
  
  End If
              r$ = r$ & Myleft$(a$, 1)
            a$ = Mid$(a$, 2)
            rr& = 1
  
            End If
       Case 36 ' "$"
       If one Then Exit Do
            If r$ <> "" Then
            one = True
            rr& = 3 ' is string variable
            r$ = r$ & Myleft$(a$, 1)
            a$ = Mid$(a$, 2)
            Else
            Exit Do
            End If
        Case 37 ' "%"
            If one Then Exit Do
            If r$ <> "" Then
            one = True
            rr& = 1 ' is long variable but here we want to be as numeric variable
            r$ = r$ & Myleft$(a$, 1)
        
            a$ = Mid$(a$, 2)
            Else
            Exit Do
            End If
        Case 40 ' "("
            If r$ <> "" And Not (Len(r$) = 1 And ExtraYes) Then
            ' m2000 specific
                'If Mid$(a$, 2, 2) = ")@" Then
                ' r$ = r$ & "()."
              'a$ = Mid$(a$, 4)
               ' Else
                Select Case rr&
                Case 1, 3, 4
                rr& = 5
                Case Else
                Exit Do
                End Select
                r$ = r$ & Myleft$(a$, 1)
                a$ = Mid$(a$, 2)
               Exit Do
            
            'End If
           Else
           Exit Do
            End If
        Case Else
        Exit Do
        End Select
        Else
            If one Then
            Exit Do
            Else
             r$ = r$ & Myleft$(a$, 1)
            a$ = Mid$(a$, 2)
            rr& = 1 'is an identifier or floating point variable
            End If
        End If
    Loop
    ' SPECIFIC M2000 - FOR HTML COLORS
    If rr& > 0 Then
        If Myleft$(r$, 1) = "#" Then
          If Len(r$) > 1 Then
            If Mid$(r$, 2) Like "[0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f]" Then
                rr& = 10
            Else
                a$ = r$ + a$
                rr& = 0
            End If
         Else
            a$ = r$ + a$
             rr& = 0
        End If
        End If
    End If
If ExtraYes And Len(r$) = 1 Then
    a$ = r$ + a$
    r$ = vbNullString
    IsLabelOnly = 0
Else
If use14 Then
    IsLabelOnly = 10
Else
    IsLabelOnly = rr& + Extra&
    End If
    End If
   
End Function
Private Function MaybeIsSymbol(a$, c$, Optional tail$ = vbNullString, Optional Remove As Boolean = False) As Boolean
Dim i As Long, ok As Boolean
If a$ = vbNullString Or c$ = vbNullString Then Exit Function
i = 1
While Mid$(a$, i, 1) = " "
    i = i + 1
Wend
If i > Len(a$) Then Exit Function
ok = InStr(c$, Mid$(a$, i, 1)) > 0
If tail$ <> "" And ok Then
ok = Mid$(a$, i + 1, Len(tail$)) Like tail$
End If
If Remove Then If ok Then a$ = Mid$(a$, i + 1 + Len(tail$))
MaybeIsSymbol = ok
End Function
Private Function MaybeIsSymbol2(a$, num As Long, c$, Optional num2 As Long, Optional tail$ = vbNullString, Optional Remove As Boolean = False) As Boolean
If num <= 0 Then Exit Function
Dim i As Long, ok As Boolean
If a$ = vbNullString Or c$ = vbNullString Then Exit Function
i = 1
While Mid$(a$, i, 1) = " "
    i = i + 1
Wend
If i > num Then Exit Function
ok = Mid$(a$, i, num) Like c$
If num2 > 0 And ok Then
ok = Mid$(a$, i + num, num2) Like tail$  '' tail$="[abc]" for one num2
End If
If Remove Then If ok Then a$ = Mid$(a$, i + num + num2)
MaybeIsSymbol2 = ok
End Function

Private Function MaybeIsSymbolNoSpace(a$, c$, Optional Remove As Boolean = False) As Boolean
Dim ok As Boolean

If a$ = vbNullString Then Exit Function
ok = InStr(c$, Myleft$(a$, 1))
If Remove And ok Then a$ = Mid$(a$, 2)
MaybeIsSymbolNoSpace = ok
End Function
Private Sub mDoc_ColorDataEvent(thispara As Long, data1 As String, feedback As Long)
col() = mDoc.Paracolordata(thispara)
Dim data As String
data = Replace(data1, vbTab, " ")
Dim feedthis As Long, oldpara As Long
oldpara = thispara
If OtherSymbols = vbNullString Then OtherSymbols = ";"

If mNoColor Then
If UBound(col()) > 1 Then
ReDim col(1)
mDoc.Paracolordata(thispara) = col()
End If
Exit Sub
End If
ReDim col(1)
Dim a$, k As Long, drop$, pos1 As Long, pos2 As Long, onetime As Boolean, kind As Long
Dim lastcol As Long
a$ = data
onetime = True
 k = Len(a$)
If k < 1 Then
makebase 14
mDoc.Paracolordata(thispara) = col()
Exit Sub
End If
If feedback > 0 Then
lastcol = 15
GoTo marvel
ElseIf MultiLineComment1 <> "{" Then
If FastSymbol(a$, MultiLineComment1, , Len(MultiLineComment1)) Then
If pos2 > 0 Then
  addone pos2, 15
  
  Else
  makebase 15
  addone 1, 15
  End If
feedback = 15
mDoc.Paracolordata(thispara) = col()
Exit Sub
End If
lastcol = 14
Else
lastcol = 14
End If
again:
If RTrim$(a$) = vbNullString Then
If pos2 > 0 Then
  addone pos2, lastcol
  Else
  makebase 14
  End If
mDoc.Paracolordata(thispara) = col()
Exit Sub
' FOR TESTS
  pos1 = 0
  For k = 1 To UBound(col()) Step 2
    If VarType(col(k)) = 0 Then mDoc.Paracolordata(thispara) = col(): Exit Sub
    If col(k) > pos1 Then pos1 = col(k)
    If col(k) < pos1 Then mDoc.Paracolordata(thispara) = col(): Exit Sub
  Next k
    For k = 0 To UBound(col()) Step 2
   If col(k) > 15 Then mDoc.Paracolordata(thispara) = col(): Exit Sub
  Next k
  
End If
While FastSymbol(a$, ":")
If pos2 > 0 Then
addone pos2, 14
Else
addone 1, 14
End If
 pos2 = k - Len(a$) + 1
Wend
' these ~(), @(), $() are M2000 specific
'drop$ = "@(": kind = Abs(FastSymbol(a$, drop$, , 2)) * 4
If kind = 0 Then
If IsSymbol(a$, "@") Then
        If pos2 > 0 Then
        addone pos2, 14
        Else
        addone 1, 14
        End If
     pos2 = k - Len(a$) + 1
End If
End If
kind = IsLabelDot("", a$, drop$)

'If kind = 0 Then drop$ = "$(": kind = Abs(FastSymbol(a$, drop$, , 2)) * 4
'If kind = 0 Then drop$ = "~(": kind = Abs(FastSymbol(a$, drop$, , 2)) * 4
If kind = 0 Then drop$ = vbNullString
If kind > 0 Then
    If IsmineHere(drop$) Then
                lastcol = 11
                If pos2 > 0 Then
                   addone pos2, 11
                Else
                   addone k - Len(a$) - Len(drop$) + 1, 11
                   End If
        '' for the end
                If IsmineHere1(drop$) Then
              
                kind = -2
                If Trim$(a$) <> "" Then
                                        pos2 = k - Len(a$) + 1
                                        If FastSymbol(a$, "{") Then
                                            addone pos2, 14
                                            pos2 = k - Len(a$) + 1
                                            onetime = True
                                            GoTo again
                                        ElseIf IsmineHere2(drop$) Then
                                        onetime = True
                                        kind = -2
                                        GoTo again2
                                        End If
                                End If
                ElseIf IsmineHere1(drop$) Then
                  
                kind = -1
                                If Trim$(a$) <> "" Then
                                                  pos2 = k - Len(a$) + 1
                                        If FastSymbol(a$, "{") Then
                                    
                                                  addone pos2, 14
                                              
                                                  pos2 = k - Len(a$) + 1
                                                  
                                                  onetime = True
                                                  GoTo again
                                          Else
                                           mDoc.Paracolordata(thispara) = col()
                                                  Exit Sub
                                        End If
                                End If
                            
                End If
    
   Else
                lastcol = 10
                If pos2 > 0 Then
                 addone pos2, 10
                Else
                 addone k - Len(a$) - Len(drop$) + 1, 10
                
                 End If
  End If
  pos2 = k - Len(a$) + 1
  If kind > 3 Then
herecol:
  pos1 = 1
 drop$ = aheadstatus(a$, False, pos1)
''  pos1 = Len(A$) + 1

marvel:

  If pos1 > 1 Then
marvel2:

 ColorizeExpressions Mid$(a$, 1, pos1 - 1), k - Len(a$) + pos1 - 1, pos2, feedthis

 If feedthis = 1 Then
 mDoc.Paracolordata(thispara) = col()
 Exit Sub
 End If
 feedback = feedthis
  a$ = Mid$(a$, pos1)
  If SeekNextLine And a$ = vbNullString Then
  thispara = 0
  drop$ = mDoc.NextTextParagraph(oldpara, thispara)
  If thispara <> 0 Then
  ' for java
  If MaybeIsSymbol(drop$, ";,+-*/&|!=)" + Chr(34)) Then
  mDoc.Paracolordata(oldpara) = col()
    
    a$ = drop$
    k = Len(a$)
    pos2 = 1
    ReDim col(1)
    kind = 0
   oldpara = thispara
  End If
  Else
  thispara = oldpara
  End If
  End If

  If FastSymbol(a$, ",") Then
       addone pos2, 14
    pos2 = k - Len(a$) + 1
  pos1 = 1
  drop$ = aheadstatus(a$, False, pos1)
GoTo marvel2
ElseIf MaybeIsSymbol(a$, OtherSymbols, , True) Then
addone pos2, 14
    pos2 = k - Len(a$) + 1
  pos1 = 1
  drop$ = aheadstatus(a$, False, pos1)
GoTo marvel2

End If
  
  End If
  If SeekNextLine And a$ = vbNullString Then
  thispara = 0
  drop$ = mDoc.NextTextParagraph(oldpara, thispara)
  If thispara <> 0 Then
  ' for java
  If MaybeIsSymbol(drop$, ";,+-*/&|!=)" + Chr(34)) Or kind > 4 Then
  mDoc.Paracolordata(oldpara) = col()
  If mDoc.startfrom(oldpara) = 0 Then
  mDoc.startfrom(oldpara) = oldpara
  End If
  mDoc.startfrom(thispara) = mDoc.startfrom(oldpara)
  kind = 0
    a$ = drop$
    k = Len(a$)
    pos2 = 1
    ReDim col(1)
    oldpara = thispara
   GoTo herecol
   Else
   thispara = oldpara
  End If
  Else
  thispara = oldpara
  End If
  End If
    If FastSymbol(a$, ")") Then
  addone pos2, lastcol ' 'lastcol
    pos2 = k - Len(a$) + 1
  End If
  End If
If FastSymbol(a$, ".") Then
  addone pos2, lastcol
    pos2 = k - Len(a$) + 1
End If
If FastSymbol(a$, "<=", , 2) Then
  addone pos2, 15
    pos2 = k - Len(a$) + 1
    Else
  
again4:
  If FastSymbol(a$, "=") Then
  addone pos2, 15
    pos2 = k - Len(a$) + 1
  ElseIf MaybeIsSymbol(a$, "+-*/", "=", True) Then
  addone pos2, 14
    pos2 = k - Len(a$) + 1
  ElseIf MaybeIsSymbolNoSpace(a$, "~", True) Then
  addone pos2, 14
    pos2 = k - Len(a$) + 1
End If
  End If
again2:
Do
again3:
  pos1 = 1
 '' kind = -2 maybe
a$ = NLtrim$(a$)
  drop$ = aheadstatus(a$, False, pos1)
  
  If pos1 > 1 Or drop$ = "S" Then
  If pos1 = 1 Then
  drop$ = a$
  pos1 = Len(a$) + 1
  Else
  drop$ = Mid$(a$, 1, pos1 - 1)
  If drop$ = vbNullString Then drop$ = " "
  End If
feedback = 0
 ColorizeExpressions drop$, k - Len(a$) + pos1 - 1, pos2, feedback
 If drop$ = "(" Then
If feedback = 100 Then
    lastcol = 14
End If
End If
 If feedback = 1 Then
 feedthis = 0
 mDoc.Paracolordata(thispara) = col()
 Exit Sub
 End If
  a$ = Mid$(a$, pos1)   '''was pos1
    If SeekNextLine And a$ = vbNullString Then
  thispara = 0
  drop$ = mDoc.NextTextParagraph(oldpara, thispara)
  If thispara <> 0 Then
  
  ' for java
  If MaybeIsSymbol(drop$, ";,+-*/&|!=)" + Chr(34)) Then
  mDoc.Paracolordata(oldpara) = col()
    kind = 0
    a$ = drop$
    k = Len(a$)
    pos2 = 1
    ReDim col(1)
    oldpara = thispara
   
  End If
  Else
  thispara = oldpara
  End If
  End If
''  If InStr(DROP$, " ") = 0 Then
If InStr(drop$, " ") = 0 Or kind >= 0 Then GoTo again3
  End If
    If MaybeIsSymbol(a$, OtherSymbols, , True) Then
     addone pos2, 14
    pos2 = k - Len(a$) + 1
    onetime = False
    ElseIf FastSymbol(a$, "}") Then
         addone pos2, 14
    pos2 = k - Len(a$) + 1
    onetime = True
    GoTo again
   Else
   onetime = True
   Exit Do
   End If
   Loop

GoTo again
ElseIf MaybeIsSymbol(a$, LineComment2) Then
If pos2 > 0 Then
 addone pos2, 7

Else
addone 1, 7
End If
 pos2 = k - Len(a$) + 1
 mDoc.Paracolordata(thispara) = col()
 Exit Sub
ElseIf MaybeIsSymbol2(a$, ComSymbolsWidth, CommentSymbols) Then
If pos2 > 0 Then
 addone pos2, 7

Else
addone 1, 7
End If
 pos2 = k - Len(a$) + 1
 mDoc.Paracolordata(thispara) = col()
 Exit Sub
ElseIf Not onetime Then
If FastSymbol(a$, ",") Then
ElseIf FastSymbol(a$, ":") Then
onetime = True
ElseIf FastSymbol(a$, ")") Then
addone pos2, lastcol
pos2 = k - Len(a$) + 1
    GoTo again4
ElseIf MaybeIsSymbol(a$, OtherSymbols, , True) Then
addone pos2, 14
    pos2 = k - Len(a$) + 1
    GoTo again2
ElseIf FastSymbol(a$, "}") Then
addone pos2, 14
addone k - Len(a$), 11
pos2 = k - Len(a$) + 1
    GoTo again3

ElseIf FastSymbol(a$, "{") Then
onetime = True
ElseIf FastSymbol(a$, "?") Then
addone pos2, 14
addone k - Len(a$), 11
pos2 = k - Len(a$) + 1
GoTo again2
Else
addone pos2, lastcol
mDoc.Paracolordata(thispara) = col()
Exit Sub
End If
addone pos2, 14
    pos2 = k - Len(a$) + 1
    GoTo again
ElseIf IsSymbol(a$, "?") Then

addone 1, 11
        pos2 = k - Len(a$) + 1
        GoTo again2
ElseIf IsSymbol(a$, "=") Then

If pos2 > 0 Then
addone pos2, 11
Else
addone 1, 11
End If
        pos2 = k - Len(a$) + 1
        GoTo again2
ElseIf FastSymbol(a$, "{") Then
onetime = True
If pos2 > 0 Then
addone pos2, 14
 pos2 = k - Len(a$) + 1
    If FastSymbol(a$, "&") Then
          addone pos2, 10
      pos2 = k - Len(a$) + 1
End If
Else
addone 1, 14
    pos2 = k - Len(a$) + 1
End If
    
        GoTo again

ElseIf FastSymbol(a$, "}") Then
If pos2 > 0 Then
addone pos2, 14
Else
addone 1, 14
End If
        pos2 = k - Len(a$) + 1
        GoTo again

ElseIf pos2 = 0 Then
If AutoNumber Then
If IsNumberLabel(a$, drop$) Then
        addone k - Len(a$) - Len(drop$) + 1, 15
        pos2 = k - Len(a$) + 1
        GoTo again
 End If
 End If
 End If
If pos2 > 0 Then addone pos2, 14

End Sub


Private Sub mDoc_Lastline()
If showparagraph Then showparagraphonce = True
End Sub


Private Sub mDoc1_BreakLine(data As String, datanext As String)
If NoHeadwrap Or (NoTitle) Or UsedAsTextBox Then
    datanext = data
    data = vbNullString
Else
 glistN.BreakLine data, datanext
End If
End Sub
Private Sub FillBack(thathDC As Long, there As RECT, bgcolor As Long)
' create brush
Dim my_brush As Long
my_brush = CreateSolidBrush(bgcolor)
FillRect thathDC, there, my_brush
DeleteObject my_brush
End Sub
 Private Sub PrintItem1(mHdc As Long, c As String, r As RECT, Optional way As Long = DT_NOPREFIX Or DT_NOCLIP)
 Dim cc As String
r.Top = r.Top + TextPixelOffset
 If showparagraphonce Then
         cc = c & ""
  DrawText mHdc, StrPtr(cc), -1, r, way
 Else
  DrawText mHdc, StrPtr(c), -1, r, way
   
    End If
    r.Top = r.Top - TextPixelOffset
    End Sub
 Private Sub PrintItem(mHdc As Long, c As String, r As RECT, Optional way As Long = DT_SINGLELINE Or DT_NOPREFIX Or DT_NOCLIP)
  r.Top = r.Top + TextPixelOffset
  DrawText mHdc, StrPtr(c), -1, r, way
r.Top = r.Top - TextPixelOffset
    End Sub
     Private Sub PrintItem2(mHdc As Long, c As String, r As RECT, Optional way As Long = DT_SINGLELINE Or DT_NOPREFIX Or DT_NOCLIP)
 Dim that As Long
 that = way
 r.Left = r.Left + 4
If glistN.VerticalCenterText Then that = that Or DT_VCENTER

    DrawText mHdc, StrPtr(c), -1, r, that

    End Sub
Public Property Get EditDoc() As Boolean
EditDoc = mEditDoc
End Property

Public Property Let EditDoc(ByVal RHS As Boolean)
mEditDoc = RHS
If Not RHS Then glistN.MarkNext = 0
glistN.EditFlag = RHS
If glistN.enabled Then
glistN.ShowMe2
End If
End Property

Public Property Get ParaSelStart() As Long
If glistN.ListIndex < 0 Then ParaSelStart = 1: Exit Property
Dim what$, ThatPara As Long, pastchars
    pastchars = mDoc.TextParagraphLine(glistN.ListIndex + 1, what$, ThatPara)
Charpos = pastchars + glistN.SelStart
If Charpos = 0 Then
ParaSelStart = 1
Else
ParaSelStart = Charpos
End If
End Property
Public Sub WrapAll()
If mDoc Is Nothing Then Exit Sub
mDoc.WrapAgain
End Sub
Public Property Let ParaSelStart(ByVal RHS As Long)
' we have a new ParaSelStart
' we want a new listindex...and a new selstart

Charpos = RHS
Render
End Property

Public Property Get nowrap() As Boolean
nowrap = mNoWrap
End Property

Public Property Let nowrap(ByVal RHS As Boolean)
If UsedAsTextBox Then Exit Property
If Not (mNoWrap = RHS) Then
mNoWrap = RHS
glistN.NoScroll = Not mNoWrap
    If Not mDoc.IsEmpty Then
    WrapAll
   If HaveMarkedText Then RelocateMarkedText
    
    HorSrcoll 0
    Render
    End If
End If
End Property

Public Property Get enabled() As Boolean
enabled = glistN.enabled
End Property

Public Property Let enabled(ByVal RHS As Boolean)
'glistN.HideCaretOnexit = Not rhs
If Not RHS Then
glistN.Noflashingcaret = False
Show
End If
glistN.enabled = RHS
End Property
Sub SetFocus()
If glistN.Visible Then glistN.SetFocus
End Sub

Public Property Get ScrollKeyUpDown() As Boolean
ScrollKeyUpDown = glistN.NoFreeMoveUpDown
End Property

Public Property Let ScrollKeyUpDown(ByVal RHS As Boolean)
glistN.NoFreeMoveUpDown = RHS
End Property
Public Sub SetRowColumn(Row As Long, ByVal Column As Long, Optional noShow As Boolean = False)
' base 0 for column as input
Column = Column + 1
' base 1
If Column < 0 Then Column = 0
If Row = -1 Then
glistN.ListindexPrivateUse = glistN.listcount - 1
Else
If Row > glistN.listcount + 1 Then
Row = glistN.listcount + 1
End If
glistN.ListindexPrivateUse = Row - 1  ' no events
End If
Dim a As String, b As Long
mDoc.TextParagraphLine glistN.ListIndex + 1, a, b
mDoc.MarkParagraphID = b
If Len(glistN.list(glistN.ListIndex)) < Column Then
If Row = glistN.listcount + 1 Then
glistN.SelStartEventAlways = Len(glistN.list(glistN.ListIndex))
Else
glistN.SelStartEventAlways = Column  'Len(glistN.List(glistN.listindex)) + 1
End If
Else
glistN.SelStartEventAlways = Column
End If
If glistN.enabled Then
If Not noShow Then glistN.ShowMe
End If
End Sub
Public Function TextFormatBreak(lineBreaker As String) As String
Text = mDoc.textFormat(lineBreaker)
End Function

Public Property Get Text() As String
If mDoc Is Nothing Then Exit Property
Text = mDoc.textDoc
End Property
Public Property Let Text(RHS As String)
On Error Resume Next
If glistN Is Nothing Then Exit Property
If UsedAsTextBox Or NumberOnly Or NumberIntOnly Then
If Not mNoWrap = True Then
    mNoWrap = True
    glistN.NoScroll = False
End If

End If
Dim oldenabled As Boolean
If Me.HaveMarkedText Then
BlockStartPara = BlockEndPara
BlockStartPos = BlockEndPos

glistN.MarkNext = 0
End If
oldenabled = glistN.enabled
glistN.enabled = False
Set mDoc = New Document
mDoc.ColorEvent = True
mDoc.final = mMultiLineComment2
mDoc.textDoc = RHS
glistN.ListindexPrivateUse = 0
para1 = 0
PosPara1 = 0
Para2 = 0
PosPara2 = 0
Para3 = 0
PosPara3 = 0
BlockStartPara = 0
BlockStartPos = 0
BlockStartLine = 0
BlockTopline = 0
BlockStartCursor = 0
BlockEndCursor = 0
BlockEndPara = 0
BlockEndPos = 0
BlockEndline = 0
BlockBottomline = 0
Charpos = 0
all = mDoc.DocLines
 glistN.SelStart = 0
ClearRedo
ClearUndo
glistN.enabled = oldenabled
Dim what$, ThatPara As Long, pastchars
   pastchars = mDoc.TextParagraphLine(1, what$, ThatPara)
mDoc.MarkParagraphID = ThatPara
End Property
Public Property Get TextParagraphs() As Long
TextParagraphs = mDoc.DocParagraphs
End Property
Public Property Get TextLines() As Long
TextLines = mDoc.DocLines
End Property
Public Property Let LineSpacingSilent(ByVal RHS As Long)
RHS = Abs(RHS) + 2
glistN.addpixels = RHS
''Render
End Property
Public Property Let LineSpacing(ByVal RHS As Long)
RHS = Abs(RHS) + 2
glistN.addpixels = RHS
Render
End Property

Public Property Get SelLength() As Long
If HaveMarkedText Then
If BlockStartLine = BlockEndline Then
SelLength = Abs(BlockStartCursor - BlockEndCursor)
Else
Dim a$(), oldmydoc As Document, i As Long, sum As Long
' maybe we didn't need to preserve old UndoDoc...I need to clarify this..
Set oldmydoc = UndoDoc
Set UndoDoc = New Document
FillBlock
sum = UndoDoc.SizeCRLF + 2
If UndoDoc.LfLead Then sum = sum - 1
If UndoDoc.CrTail Then sum = sum + 1
SelLength = sum - 2 ' no the last vbcrlf
End If
Set UndoDoc = oldmydoc
End If
End Property
Public Property Let SelLengthSilent(ByVal RHS As Long)
If RHS <= 0 Then
    ' a copy of glistN_MarkDestroyAny
    BlockEndPara = mDoc.MarkParagraphID
    BlockStartPara = BlockEndPara
    BlockStartPos = BlockEndPos
    glistN.MarkNext = 0
'If glistN.Enabled Then glistN.ShowPan
Else
glistN.MarkNext = 1
   BlockStartCursor = glistN.SelStart
    BlockStartPara = mDoc.MarkParagraphID
    BlockStartPos = ParaSelStart  ' selstart isn't from start of the doc...
 
    BlockStartLine = glistN.ListIndex
        BlockEndPara = BlockStartPara
        BlockEndPos = BlockStartPos
        BlockEndline = BlockStartLine
    BlockEndCursor = BlockStartCursor + 1
    
mDoc.FindPos BlockStartLine + 1, BlockStartCursor, RHS, BlockEndline, BlockEndCursor, BlockEndPara, BlockEndPos

BlockEndline = BlockEndline - 1 ' base 0


    BlockTopline = BlockStartLine
    BlockBottomline = BlockEndline
If RHS <> 0 Then
glistN.MarkNext = 2
'If glistN.Enabled Then glistN.ShowPan
End If
End If
End Property
Public Property Let SelLength(ByVal RHS As Long)
If RHS <= 0 Then
    ' a copy of glistN_MarkDestroyAny
    BlockEndPara = mDoc.MarkParagraphID
    BlockStartPara = BlockEndPara
    BlockStartPos = BlockEndPos
    glistN.MarkNext = 0
If glistN.enabled Then glistN.ShowPan
Else
glistN.MarkNext = 1
   BlockStartCursor = glistN.SelStart
    BlockStartPara = mDoc.MarkParagraphID
    BlockStartPos = ParaSelStart  ' selstart isn't from start of the doc...
 
    BlockStartLine = glistN.ListIndex
        BlockEndPara = BlockStartPara
        BlockEndPos = BlockStartPos
        BlockEndline = BlockStartLine
    BlockEndCursor = BlockStartCursor + 1
    
mDoc.FindPos BlockStartLine + 1, BlockStartCursor, RHS, BlockEndline, BlockEndCursor, BlockEndPara, BlockEndPos

BlockEndline = BlockEndline - 1 ' base 0

    BlockTopline = BlockStartLine
    BlockBottomline = BlockEndline
If RHS <> 0 Then
glistN.MarkNext = 2
If glistN.enabled Then glistN.ShowPan
End If
End If
End Property

Public Property Get Visible() As Boolean
Visible = glistN.Visible
End Property

Public Property Let Visible(ByVal RHS As Boolean)
glistN.Visible = RHS
End Property
Public Property Get FontSize() As Single

  FontSize = glistN.FontSize
 
End Property

Public Property Let FontSize(New_FontSize As Single)
glistN.FontSize = New_FontSize
End Property
Public Property Get Font() As Font
 Set Font = glistN.Font
End Property

Public Property Set Font(New_Font As Font)
    Set glistN.Font = New_Font
End Property
Public Property Let backcolor(ByVal RHS As OLE_COLOR)

    
glistN.backcolor = RHS
  
    
End Property
Public Property Get backcolor() As OLE_COLOR
    backcolor = glistN.backcolor
End Property
Public Property Get ForeColor() As OLE_COLOR
    ForeColor = glistN.ForeColor
End Property

Public Property Let ForeColor(ByVal RHS As OLE_COLOR)

    glistN.ForeColor = RHS

End Property

Public Property Get Top() As Long
Top = Callback.Controls(ctrlName).Top
End Property

Public Property Let Top(ByVal RHS As Long)
Callback.Controls(ctrlName).Top = RHS
End Property
Public Property Get Left() As Variant
Left = Callback.Controls(ctrlName).Left
End Property

Public Property Let Left(ByVal RHS As Variant)
Callback.Controls(ctrlName).Left = RHS
End Property
Public Property Get Height() As Long
Height = glistN.HeightTwips
End Property

Public Property Let Height(ByVal RHS As Long)
glistN.HeightTwips = RHS
End Property
Public Sub Dereference()
Set glistN = Nothing
Set mDoc = Nothing
Set mDoc1 = Nothing

End Sub

Public Property Get SelText() As String
If HaveMarkedText Then
FillBlock

If UndoDoc.LfLead Then
SelText = Mid$(UndoDoc.textDoc, 2)
ElseIf UndoDoc.CrTail Then
SelText = UndoDoc.textDoc + vbCr
Else  ''If UndoDoc.LfLead = UndoDoc.CrTail Then
SelText = UndoDoc.textDoc
End If
End If
End Property
Public Property Get SelHtmlText() As String
If HaveMarkedText Then
''FillBlock
Dim curcolors(0 To 15) As Variant, i As Long
For i = 0 To 15
curcolors(i) = Right$("000000" + Hex$(htmlM2000(i)), 6)

Next i

If UndoDoc.LfLead Then
SelHtmlText = Replace(Mid$(UndoDoc.textHtmlDoc(curcolors()), 2), vbCrLf, "<br>")
Else
SelHtmlText = Replace(UndoDoc.textHtmlDoc(curcolors()), vbCrLf, "<br>")
End If


End If
End Property
Public Property Let SelText(ByVal RHS As String)
Dim kk As Long, Pad$


kk = SelStart
SelStart = kk
glistN_MarkDelete False
glistN.MarkNext = 1
BlockStartPara = mDoc.MarkParagraphID
BlockStartPos = ParaSelStart
BlockStartCursor = glistN.SelStart '- 1
BlockEndCursor = BlockStartCursor + 1
BlockStartLine = glistN.ListIndex
BlockEndline = BlockStartLine
BlockEndPara = BlockStartPara
BlockEndPos = BlockStartPos
Dim k As Long, l As Long
If Right$(RHS, 1) = vbCr Then RHS = RHS + vbLf
If RHS <> "" Then

If NumberOnly Then
If undotext = vbNullString Then
undotext = glistN.list(0)
ElseIf glistN.list(0) = vbNullString And undotext <> "" Then
glistN.list(0) = undotext
End If
Pad$ = Space$(Len(RHS) + Len(glistN.list(0)))
Mid$(Pad$, 1, Charpos - 1) = Myleft$(glistN.list(0), Charpos - 1)
Mid$(Pad$, Charpos, Len(RHS)) = RHS
If Len(glistN.list(0)) > 0 Then
If Mid$(glistN.list(0), Charpos) <> "" Then
Mid$(Pad$, Charpos + Len(RHS) - 1) = Mid$(undotext, Charpos)
End If
End If
RHS = glistN.list(0)
 glistN.list(0) = Pad$
If Not glistN.list(0) = Pad$ Then glistN.list(0) = RHS: undotext = vbNullString
Else
mDoc.InsertDoc mDoc.MarkParagraphID, Charpos, RHS, tabwidth
End If
Render
End If
BlockEndPara = mDoc.MarkParagraphID
BlockEndPos = ParaSelStart
BlockEndline = glistN.ListIndex
BlockEndCursor = glistN.SelStart
If BlockEndline < BlockStartLine Then
    BlockTopline = BlockEndline
    BlockBottomline = BlockStartLine
Else
    BlockTopline = BlockStartLine
    BlockBottomline = BlockEndline
End If


k = kk
glistN.MarkNext = 2
SelStart = k

End Property
Public Property Let InsertTextNoRender(ByVal RHS As String)
Dim b As Boolean
ClearRedo
PushUndo
glistN_MarkDelete False
glistN.MarkNext = 0
undomode = 5 ' like 1
RemoveUndo (RHS)
undomode = 4 ' like 0
b = enabled
If b Then enabled = False
Dim k As Long, l As Long
If Right$(RHS, 1) = vbCr Then RHS = RHS + vbLf
If RHS <> "" Then


mDoc.InsertDoc mDoc.MarkParagraphID, Charpos, RHS
all = mDoc.DocLines

End If
If b <> enabled Then enabled = b
End Property
Private Property Let InsertText2(ByVal RHS As String)
glistN_MarkDelete True
glistN.MarkNext = 0
If Right$(RHS, 1) = vbCr Then RHS = RHS + vbLf
mDoc.ResetColor mDoc.MarkParagraphID
mDoc.InsertDoc mDoc.MarkParagraphID, Charpos, RHS
End Property
Public Property Let InsertText(ByVal RHS As String)
glistN_MarkDelete False
glistN.MarkNext = 0
Dim k As Long, l As Long
If Right$(RHS, 1) = vbCr Then RHS = RHS + vbLf
If RHS <> "" Then
mDoc.ResetColor mDoc.MarkParagraphID
mDoc.InsertDoc mDoc.MarkParagraphID, Charpos, RHS
Render

End If
End Property
Public Property Get CharPosStart() As Long
Dim findit As Long
Dim a As Long, b As Long, c As Long, d As Long
findit = -1
mDoc.FindPos glistN.ListIndex + 1, glistN.SelStart, findit, a, b, c, d
CharPosStart = findit
End Property
Public Property Get SelStart() As Long
'
Dim findit As Long
Dim a As Long, b As Long, c As Long, d As Long
findit = -1
If glistN.MarkNext > 0 Then
If BlockTopline = BlockBottomline Then
If BlockStartCursor < BlockEndCursor Then
mDoc.FindPos BlockTopline + 1, BlockStartCursor, findit, a, b, c, d
Else
mDoc.FindPos BlockTopline + 1, BlockEndCursor, findit, a, b, c, d
End If
ElseIf BlockTopline = BlockStartLine Then
mDoc.FindPos BlockTopline + 1, BlockStartCursor, findit, a, b, c, d
Else
mDoc.FindPos BlockTopline + 1, BlockEndCursor, findit, a, b, c, d
End If
Else
mDoc.FindPos glistN.ListIndex + 1, glistN.SelStart, findit, a, b, c, d
End If
If findit <> -1 Then LastSelStart = findit
SelStart = findit
End Property

Public Property Let SelStart(ByVal RHS As Long)
Dim findit As Long, sel1 As Long
sel1 = SelLength
    BlockEndPara = mDoc.MarkParagraphID
    BlockStartPara = BlockEndPara
    BlockStartPos = BlockEndPos
    glistN.MarkNext = 0
Dim a As Long, b As Long, c As Long, d As Long
findit = RHS
mDoc.FindPos 1, 0, findit, a, b, c, d

SetRowColumn a, b, sel1 <> 0
If sel1 <> 0 Then SelLength = sel1: LastSelStart = sel1
End Property
Public Property Let SelStartSilent(ByVal RHS As Long)
Dim findit As Long
Dim a As Long, b As Long, c As Long, d As Long
LastSelStart = RHS
findit = RHS
mDoc.FindPos 1, 0, findit, a, b, c, d
SetRowColumn a, b, True
End Property

Sub ClearUndo()
undopara = -1
NeoUndo = 0
UndoMax = 20
ReDim MultiUndo(1 To UndoMax)
End Sub
Function FindNewUndo() As Long
If NeoUndo = 0 Then
UndoMax = 20
ReDim MultiUndo(1 To UndoMax)
End If
NeoUndo = NeoUndo + 1
If NeoUndo > UndoMax Then
UndoMax = UndoMax * 2
ReDim Preserve MultiUndo(1 To UndoMax)
ElseIf UndoMax > 20 And NeoUndo < UndoMax / 2 Then
UndoMax = UndoMax / 2
ReDim Preserve MultiUndo(1 To UndoMax)
End If
FindNewUndo = NeoUndo
End Function
Private Sub PushUndo()
If undopara = -1 Then Exit Sub
Dim b As Long
b = FindNewUndo
With MultiUndo(b)
.undotext = undotext  ' new  seltext
.undopara = undopara  ' not need for this 2nd version
.undomode = undomode  ' needed
.undopos = undopos  ' new not charpos but selstart
undopos = ParaSelStart
undotext = vbNullString
undopara = mDoc.MarkParagraphID  ' nod needed maybe for trace errors later
undomode = -1
undopara = -1
End With
End Sub
Private Function PopUndo() As Boolean
' false ...no undo saved
If NeoUndo < 1 Then Exit Function

With MultiUndo(NeoUndo)
undotext = .undotext
.undotext = vbNullString  ' flush
undopara = .undopara
undomode = .undomode
undopos = .undopos
End With
NeoUndo = NeoUndo - 1
PopUndo = True
If undopara < 0 Then Exit Function

End Function
Sub ClearRedo()
Redopara = -1
NeoRedo = 0
RedoMax = 20
ReDim MultiRedo(1 To RedoMax)
End Sub
Function FindNewRedo() As Long
If NeoRedo = 0 Then
RedoMax = 20
ReDim MultiRedo(1 To RedoMax)
End If
NeoRedo = NeoRedo + 1
If NeoRedo > RedoMax Then
RedoMax = RedoMax * 2
ReDim Preserve MultiRedo(1 To RedoMax)
ElseIf RedoMax > 20 And NeoRedo < RedoMax / 2 Then
RedoMax = RedoMax / 2
ReDim Preserve MultiRedo(1 To RedoMax)
End If
FindNewRedo = NeoRedo
End Function
Private Sub PushRedo()

If Redopara = -1 Then Exit Sub
Dim b As Long
b = FindNewRedo
With MultiRedo(b)
.undotext = Redotext
.undopara = Redopara
.undomode = Redomode
.undopos = Redopos
Redopos = ParaSelStart
Redotext = vbNullString
Redopara = mDoc.MarkParagraphID
Redomode = -1
End With
End Sub
Private Function PopRedo() As Boolean
' false ...no Redo saved
If NeoRedo < 1 Then Exit Function
With MultiRedo(NeoRedo)
Redotext = .undotext
.undotext = vbNullString  ' flush
Redopara = .undopara
Redomode = .undomode
Redopos = .undopos
End With
NeoRedo = NeoRedo - 1
PopRedo = True
End Function

Public Sub ResetUndoRedo()
ClearUndo
ClearRedo
Redopara = -1
undopara = -1
End Sub
Public Function CurrentParagraph() As String
'If showparagraphWork And showparagraph Then
'CurrentParagraph = Replace(Replace(mdoc.TextParagraph(mdoc.MarkParagraphID), " ", ChrW(&HB7)), ChrW(&H2007), ChrW(&H2423))
'Else
CurrentParagraph = mDoc.TextParagraph(mDoc.MarkParagraphID)
'End If
End Function
Public Function NextParagraph() As String
Dim dummy As Long
If showparagraphWork And showparagraph Then
NextParagraph = Replace(Replace(mDoc.NextTextParagraph(mDoc.MarkParagraphID, dummy), " ", ChrW(&HB7)), ChrW(&H2007), ChrW(&H2423))
Else
NextParagraph = mDoc.NextTextParagraph(mDoc.MarkParagraphID, dummy)
End If
End Function
Public Function AutoIntNewLine() As Boolean
' if autonumber
Dim a$, newid As Long 'mDoc.MarkParagraphID
Dim b$, c$, d$, e$, skip As Boolean, tr$, maxw As Long
showparagraphWork = False
b$ = CurrentParagraph
If AutoNumber Then
If IsNumberLabel(b$, c$) Then
d$ = NextParagraph: If d$ <> "" Then If IsNumberLabel(d$, e$) Then skip = True
If Not skip Then c$ = Trim(c$)
If e$ <> "" Then If val(e$) > val(c$) + 10 Then skip = False
If (val(c$) Mod 10 = 0) And Not skip Then
tr$ = String$(Len(Trim$(c$)), "0")
a$ = Format((val(c$) + 10), tr$) + Space$(Len(CurrentParagraph) - Len(c$) - Len(NLtrim$(b$)))
Else
If e$ <> "" And Trim$(Str((val(c$) + 1))) = Trim$(e$) Then
maxw = glistN.UserControlTextWidth(c$)
a$ = Space$(Len(c$))
While glistN.UserControlTextWidth(a$) < maxw
a$ = a$ + " "
Wend
c$ = vbNullString

Else
tr$ = String$(Len(Trim$(c$)), "0")
a$ = Format((val(c$) + 1), tr$) + Space$(Len(CurrentParagraph) - Len(Trim$(c$)) - Len(NLtrim$(b$)))
End If
End If
Else
a$ = Space$(Len(CurrentParagraph) - Len(NLtrim$(CurrentParagraph)))
End If
Else
a$ = Space$(Len(CurrentParagraph) - Len(NLtrim$(CurrentParagraph)))
If Len(a$) > Charpos Then a$ = ""
End If

If a$ <> "" Then
RemoveUndo vbCrLf + a$
InsertText = vbCrLf + a$
AutoIntNewLine = True
End If
showparagraphWork = True

End Function
Public Property Get Length() As Long
Length = mDoc.SizeCRLF
End Property


Function GetLCIDFromKeyboard() As Long
    Dim Buffer As String, ret&, r&
    Buffer = String$(514, 0)
      r = GetKeyboardLayout(DWL_ANYTHREAD) And &HFFFF
      r = val("&H" & Right(Hex(r), 4))
        ret = GetLocaleInfo(r, LOCALE_ILANGUAGE, StrPtr(Buffer), Len(Buffer))
    GetLCIDFromKeyboard = CLng(val("&h" + Myleft$(Buffer, ret - 1)))
End Function
Public Property Let ReplaceTitle(a$)  ' at the end
Dim curlines As Long
NoTitle = Title = vbNullString
NoHeadwrap = False
curlines = mDoc1.DocLines
mDoc1.EmptyDoc
mDoc1.textDoc = RTrim$(Title$ + " " + a$)
mDoc1.WrapAgain
If mDoc1.DocLines >= curlines + glistN.lines + 1 Then
mDoc1.EmptyDoc
NoHeadwrap = True
mDoc1.textDoc = RTrim$(Title$ + " " + a$)
End If
glistN.HeadLine = vbNullString ' reset
glistN.HeadLine = " " ' give a fake headline
onelineheight = glistN.HeadlineHeight
glistN.HeadlineHeight = mDoc1.DocLines * onelineheight
glistN.ShowMe

End Property
Public Property Let ReplaceTitleHold(a$)
ReplaceTitle = a$
TitleStay = a$ <> ""
End Property
Private Sub PrintItem1X(mHdc As Long, ByVal c As String, r As RECT, col() As Variant)
On Error Resume Next
    Dim cc As String, all As Long, CM As String, offset As Long, addthis As Long
      
    Dim ww$(), items&, i, rleft
    If UBound(col()) <= 1 Or mNoColor Then
        PrintItem1 mHdc, c, r
        Exit Sub
    End If
    rleft = r.Left
    all = rleft + glistN.UserControlTextWidthPixels(c)
    r.Left = all
    ww$() = SplitStringUsingArray(c, col(), items&)
    If showparagraphonce Then
        cc = ""
        DrawText mHdc, StrPtr(cc), -1, r, mway
    End If
    cc = vbNullString
    CM = c
    For i = items& To 0 Step -1
        c = ww$(i)
        CM = Myleft$(CM, Len(CM) - Len(ww$(i)))
        offset = glistN.UserControlTextWidthPixels(CM)
        ' for Kenring
        addthis = glistN.UserControlTextWidthPixels(CM + c) - offset - glistN.UserControlTextWidthPixels(c)
        r.Left = offset + rleft + addthis
        r.Top = r.Top + TextPixelOffset
        
        If Not mNoColor1 Then SetTextColor mHdc, M2000(col(i * 2))
    
        DrawText mHdc, StrPtr(c), -1, r, mway
        r.Top = r.Top - TextPixelOffset
        If r.Left < 0 Then Exit For
    Next i
    r.Left = rleft
    End Sub

    

Function colorline(ParamArray aa() As Variant) As Variant()
colorline = aa()
End Function


Function checkme(bb() As Variant, probethis As Long) As Long
Dim st&, ste&
'' checkme colorline(5, 1, 1,20,3,24,1,29),60
ste& = UBound(bb())
If probethis = -1 Then
checkme = bb(ste& - 1)
Else
For st& = 3 To ste& Step 2
    If probethis < bb(st&) Then
    
    checkme = bb(st& - 3)
    Exit Function
    End If
Next st&
checkme = bb(st& - 3)
End If
End Function
Function SplitStringUsingArray(c$, bb() As Variant, wc&) As String()
Dim cc$()
ReDim cc$((UBound(bb()) + 1) / 2)
Dim st&, ste&, w&
wc& = 0
ste& = UBound(bb())
For w& = 1 To ste& - 2 Step 2
On Error Resume Next
If bb(w& + 2) - bb(w&) < 1 Then
cc$(wc&) = Mid$(c$, bb(w&))
Else
cc$(wc&) = Mid$(c$, bb(w&), bb(w& + 2) - bb(w&))
End If
If cc$(wc&) = vbNullString Then
wc& = wc& - 1
SplitStringUsingArray = cc$()
Exit Function
End If
wc& = wc& + 1
Next w&
If bb(w&) > 0 Then
cc$(wc&) = Mid$(c$, bb(w&))
End If
If cc$(wc&) = vbNullString Then wc& = wc& - 1
SplitStringUsingArray = cc$()
End Function
Function M2000(ch As Variant) As Long
Dim b As Integer

Select Case ColorSet
Case 0
M2000 = QBColor(ch Mod 16)
Case 1
Select Case ch
Case 7
M2000 = rgb(&H68, &H68, &H13)
Case 10
M2000 = 0   '' black  '' basic
Case 11
M2000 = rgb(32, 32, 255)
Case 14
M2000 = rgb(&HAA, &H60, &H30)
Case 15
M2000 = rgb(&H63, &H30, &H63) '' string

End Select
End Select

End Function
Function htmlM2000(ch As Variant) As Long
Dim b As Integer

Select Case Abs(pagiohtml$ = "DARK")
Case 0

htmlM2000 = (QBColor(ch Mod 16) And &HFF00&) + (QBColor(ch Mod 16) \ &H10000) + ((QBColor(ch Mod 16) And &HFF) * &H10000)
Case 1
Select Case ch
Case 7
htmlM2000 = rgb(&H13, &H68, &H68)
Case 10
htmlM2000 = 0   '' black  '' basic
Case 11
htmlM2000 = rgb(255, 32, 32)
Case 14
htmlM2000 = rgb(&H30, &H60, &HAA)
Case 15
htmlM2000 = rgb(&H63, &H30, &H63) '' string

End Select
End Select

End Function
Private Function aheadstatus(a$, Optional srink As Boolean = True, Optional pos As Long = 1) As String 'ok
Dim b$, part$, w$, Level&, pos2 As Long, word$

If a$ = vbNullString Then Exit Function
If pos = 0 Then pos = 1
Do While pos <= Len(a$)

    w$ = Mid$(a$, pos, 1)
    
    If part$ = vbNullString And w$ = "0" Then
        If pos + 2 <= Len(a$) Then
            If LCase(Mid$(a$, pos, 2)) Like "0[x]" Then
            'hexadecimal literal number....
                pos = pos + 2
                Do While pos <= Len(a$)
                If Not Mid$(a$, pos, 1) Like "[0-9a-fA-F]" Then Exit Do
                pos = pos + 1
                Loop
                b$ = b$ & "N"
                If pos <= Len(a$) Then
                    w$ = Mid$(a$, pos, 1)
                Else
                    Exit Do
                End If
            End If
        End If
    End If

    If w$ = Chr(34) Then
        If part$ <> "" Then
        b$ = b$ & part$
        End If
        If Not (part$ = vbNullString Or part$ = "o") Then Exit Do
        part$ = "S"
        pos = pos + 1
        Do While pos <= Len(a$)
        If Mid$(a$, pos, 1) = Chr(34) Then Exit Do
    If Asc(Mid$(a$, pos, 1)) < 32 Then Exit Do
   
        pos = pos + 1
        Loop

    ElseIf w$ = Chr$(2) Then  ' packet string
        If part$ <> "" Then
        b$ = b$ & part$
        End If
        part$ = "S"
        '  UNPACKLNG(Mid$(a$, pos+1, 8)+10
        pos = pos + UNPACKLNG(Mid$(a$, pos + 1, 8)) + 8
        w$ = Chr(34)
   
    
    ElseIf w$ = "(" Then
        Level& = 0
        If part$ <> "" Then
            ' after
            ElseIf Right$(b$, 1) = "a" Then
            b$ = Myleft$(b$, Len(b$) - 1)
            part$ = vbNullString
            Else
            part$ = "N"
              
        End If
      pos = pos + 1
        If Not BlockParam2(a$, pos) Then Exit Do
        
       If Mid$(a$, pos + 1, 1) <> "." Then b$ = b$ & part$
        part$ = vbNullString
        
    ElseIf w$ = "{" Then

    
           '
 
    If part$ <> "" Then
        b$ = b$ & part$
        End If
           
        If b$ <> "" Then Exit Do
        part$ = "S"
        

            If pos <= Len(a$) Then
        If Not blockStringAhead(a$, pos) Then Exit Do
        End If


    Else
        Select Case w$
        Case ","  ' bye bye
        Exit Do
        Case "%"
            If part$ = vbNullString Then
            ' lathos
            End If
        Case "$"
            If part$ = vbNullString Then
                If b$ = vbNullString Then
                    part$ = "N"
                ElseIf Right$(b$, 1) = "o" Then
                    part$ = "N"
                Else
        
                    aheadstatus = b$
                    Exit Function
                End If
            ElseIf part$ = "N" Then
                    b$ = b$ & "Sa"
                    part$ = vbNullString
            End If
        Case "+", "-"
                    b$ = b$ & part$
                    If b$ = vbNullString Then
                        part$ = "o"
                    Else
                    
                part$ = "o"
                End If
        Case "/", "^"
            If Mid$(a$, pos + 1, 1) = "/" Then Exit Do
            If Mid$(a$, pos + 1, 1) = "/*" Then Exit Do
            If part$ <> "o" Then
            b$ = b$ & part$
            End If
            part$ = "o"
        Case "^"
            If Mid$(a$, pos + 1, 1) = "^" Then Exit Do
            If part$ <> "o" Then
            b$ = b$ & part$
            End If
            part$ = "o"
            
        Case "*"
            If part$ <> "o" Then
            b$ = b$ & part$
            End If
            part$ = "o"
        Case " ", ChrW(160)
'If word$ <> "" Then
 ' Select Case myUcase(word$, True)
  'Case "THEN", "ELSE", ""
  'pos = pos - 4
  'Exit Do
  'Case "ELSE.IF"
  'pos = pos - 7
  'Exit Do
  'Case ""
  'pos = pos - 6
  'Exit Do
  'Case "."
  'pos = pos - 9
  'Exit Do
  'End Select
  'End If
        word$ = vbNullString
            If part$ <> "" Then
            b$ = b$ & part$
            part$ = vbNullString
            Else
            'skip
            End If
        Case "0" To "9", "."
            If part$ = "N" Then
            ElseIf part$ = "S" Then
            
            Else
            b$ = b$ & part$
            part$ = "N"
            End If
        Case "&"
        If part$ = vbNullString Then
        part$ = "S"
        Else
        b$ = part$
        part$ = "S"
        End If
        Case "e", "E", "", ""
        word$ = word$ + w$
           If part$ = "S" Then
            
            
            ElseIf part$ = "N" Then
            
            b$ = b$ & part$
            'part$ = "N"
            End If
        Case "=", ">", "<", "~"
                If b$ & part$ <> "" Then
                w$ = Replace(b$ & part$, "a", "")
            part$ = vbNullString
               If srink Then
                  Do
                b$ = w$
                w$ = Replace(b$, "NN", "N")
                Loop While w$ <> b$
                         Do
                        b$ = w$
                          w$ = Replace(b$, "SlS", "N")
                          Loop While w$ <> b$
                            Do
                          b$ = w$
                          w$ = Replace(b$, "NlN", "N")
                          Loop While w$ <> b$
    
                Do
                b$ = w$
                w$ = Replace(b$, "NoN", "N")
                Loop While w$ <> b$
                
                Do
                b$ = w$
                w$ = Replace(b$, "SoS", "S")
                Loop While w$ <> b$
                Else
              b$ = w$
               End If
               
                If Myleft$(b$, Len(b$) - 1) <> "l" Then part$ = "l"
                Else
                Exit Do
                End If
        
        Case ")", "}", Is < " ", ":", ";", LineComment1, LineComment2
        Exit Do
        Case Else
        If part$ = "N" Then
        word$ = word$ + w$
        ElseIf part$ = "S" Then
       
        Else
        
     b$ = b$ & part$
     part$ = "N"
     word$ = word$ + w$
            End If
        End Select
        End If
        
    pos = pos + 1

Loop

    w$ = Replace(b$ & part$, "a", "")
    
    b$ = w$
If srink Then
         Do
  b$ = w$

    w$ = Replace(b$, "SlS", "N")
    Loop While w$ <> b$
      Do
    b$ = w$
    w$ = Replace(b$, "NlN", "N")
    Loop While w$ <> b$
    
    Do
    b$ = w$
    w$ = Replace(b$, "NoN", "N")
    Loop While w$ <> b$
    
    Do
    b$ = w$
    w$ = Replace(b$, "SoS", "S")
    Loop While w$ <> b$
End If
aheadstatus = b$
End Function

Public Sub Move(x, y, Optional w, Optional h)
If IsMissing(w) Then
glistN.MoveTwips CLng(x), CLng(y), 0, 0
ElseIf IsMissing(h) Then

glistN.MoveTwips CLng(x), CLng(y), CLng(w), 0
RelocateMarkedText
Else
glistN.MoveTwips CLng(x), CLng(y), CLng(w), CLng(h)
RelocateMarkedText
End If


End Sub
Public Sub deconstruct()
If Not glistN Is Nothing Then glistN.Shutdown
Set Callback = Nothing
Set glistN = Nothing
Set mDoc = Nothing
Set mDoc1 = Nothing
End Sub
Public Sub FontAttr(ThisFontName, Optional ThisMode = -1, Optional ThisBold = True)
Dim aa As New StdFont
If ThisFontName <> "" Then

aa.name = ThisFontName

If ThisMode > 7 Then aa.Size = ThisMode Else aa = 7
aa.bold = ThisBold
Set glistN.Font = aa
TextPixelOffset = Int(glistN.TextHeightOffset)
End If
End Sub

Public Property Get locked() As Boolean
locked = Not glistN.enabled
End Property

Public Property Let locked(ByVal RHS As Boolean)
glistN.enabled = Not RHS
End Property
Public Property Get index() As Long
index = mIndex
End Property

Public Property Let index(ByVal RHS As Long)
mIndex = RHS
End Property

Public Property Get Linespace() As Variant
Linespace = dv15 * (glistN.addpixels) / 2
End Property

Public Property Let Linespace(ByVal vNewValue As Variant)
    vNewValue = (vNewValue \ 30) * 60
 
glistN.addpixels = vNewValue / dv15
Render
End Property

Public Property Get LineHeight() As Variant
''
LineHeight = glistN.HeightTwips / glistN.lines
End Property
Public Sub PressKey(KeyCode As Integer, shift As Integer)
Dim b As Boolean
  b = enabled
    PressKey_A KeyCode, shift
enabled = b
  
End Sub
Private Sub PressKey_A(KeyCode As Integer, shift As Integer)
Static ctrl As Boolean, noentrance As Boolean, where As Long
Dim aa$, a$, JJ As Long, ii As Long
If noentrance Then
KeyCode = 0
Exit Sub
End If
noentrance = True
Select Case KeyCode
Case vbKeyReturn
nochange = True
If UsedAsTextBox Or NumberOnly Or NumberIntOnly Then
KeyCode = 0
If Not Callback Is Nothing Then
With Callback.Control(1)
.PressKey 13, 0
End With
End If
ElseIf AutoIntNewLine Then

KeyCode = 0
Else

End If

nochange = False

Case vbKeyControl
ctrl = True
KeyCode = 0
Case vbKeyF1
If (shift And 2) = 2 Then
If SelText <> "" Then
helpmeSub
Else

  If mIndex >= 0 Then
   Callback.Callback mesCtrlName + ".About(" + Str(mIndex) + ")"
   Else
      Callback.Callback mesCtrlName + ".About()"
      End If
End If
Else
nowrap = Not nowrap
Render
ManualInform
End If

KeyCode = 0
Case vbKeyF2
If shift <> 0 Then
If s$ = vbNullString And SelText <> "" Then s$ = SelText
If pagio$ = "GREEK" Then
s$ = InputBoxN("   :", " ", s$)
Else
s$ = InputBoxN("Search to top:", "Text Editor", s$)
End If
If s$ <> "" Then Searchup s$, shift Mod 2 = 1
shift = 0
ElseIf SelText <> "" Or s$ <> "" Then
supsub
End If

KeyCode = 0
Case vbKeyF3
If shift <> 0 Then
If s$ = vbNullString And SelText <> "" Then s$ = SelText
If pagio$ = "GREEK" Then
s$ = InputBoxN("   :", " ", s$)
Else
s$ = InputBoxN("Search to down:", "Text Editor", s$)
End If
If s$ <> "" Then SearchDown s$, shift Mod 2 = 1
shift = 0
ElseIf SelText <> "" Or s$ <> "" Then

sdnSub
End If
KeyCode = 0
Case vbKeyF4
If SelText <> "" Then mscatsub
KeyCode = 0
Case vbKeyF5
If SelText <> "" Then rthissub
KeyCode = 0
Case vbKeyF6  ' Set/Show/Reset Para1
If Not (UsedAsTextBox Or NumberOnly Or NumberIntOnly) Then MarkSoftButton para1, PosPara1
KeyCode = 0
Case vbKeyF7  'Set/Show/Reset Para2
If Not (UsedAsTextBox Or NumberOnly Or NumberIntOnly) Then MarkSoftButton Para2, PosPara2
KeyCode = 0
Case vbKeyF8  'Set/Show/Reset Para2
If Not (UsedAsTextBox Or NumberOnly Or NumberIntOnly) Then MarkSoftButton Para3, PosPara3
KeyCode = 0

Case vbKeyF9  ' Count Words
If Not (UsedAsTextBox Or NumberOnly Or NumberIntOnly) Then
If glistN.lines > 1 Then
If UserCodePage = 1253 Then
ReplaceTitle = "  :" + Str(mDoc.WordCount)
Else
ReplaceTitle = "Words in text:" + Str(mDoc.WordCount)
End If
End If
End If
KeyCode = 0
Case vbKeyF10
If Not (UsedAsTextBox Or NumberOnly Or NumberIntOnly) Then
showparagraph = Not showparagraph
mDoc.WrapAgain
Render
End If
KeyCode = 0

Case vbKeyF11
fState = fState + 1
SetME
WrapAll
ManualInform
glistN.ShowMe
KeyCode = 0
Case vbKeyTab
If Not (UsedAsTextBox Or NumberOnly Or NumberIntOnly) Then
nochange = True
shift = shift And &H1
glistN.enabled = False

If HaveMarkedText Then SelStartSilent = SelStart
JJ = SelStart
where = JJ
ii = 1 + SelStart - ParaSelStart

If SelLength > 0 Then

JJ = SelLength + JJ - ii
SelStart = ii
SelLength = JJ
JJ = where
Else
SelStart = ii
End If


If SelText <> "" Then

    a$ = vbCrLf + SelText & "*"
    If shift <> 0 Then  ' 
    a$ = Replace(a$, vbCrLf + String(6 + (Len(CurrentParagraph) - Len(LTrim(CurrentParagraph))) Mod 6, ChrW(160)), vbCrLf)
        a$ = Replace(a$, vbCrLf + Space$(6 + (Len(CurrentParagraph) - Len(LTrim(CurrentParagraph))) Mod 6), vbCrLf)
        InsertTextNoRender = Mid$(a$, 3, Len(a$) - 3)
         SelStartSilent = ii
         SelLengthSilent = Len(a$) - 3
       
    Else
        a$ = Replace(a$, vbCrLf, vbCrLf + Space$(6))
        InsertTextNoRender = Mid$(a$, 3, Len(a$) - 3)
        SelStartSilent = where + 6
        SelLengthSilent = Len(a$) - 3 - (where + 6 - ii)
  
    End If
    
'  RelocateMarkedText
Else
If shift <> 0 Then

    If Mid$(CurrentParagraph, 1, 6) = Space$(6) Or Mid$(CurrentParagraph, 1, 6) = String(6, ChrW(160)) Then

            SelStartSilent = ii
            SelLengthSilent = 6
            InsertTextNoRender = vbNullString
            SelStartSilent = ii
    Else
            SelStartSilent = ii
            SelLengthSilent = Len(CurrentParagraph) - Len(LTrim(CurrentParagraph))
            InsertTextNoRender = vbNullString
            SelStartSilent = ii
    
    End If
    Else
        SelStartSilent = JJ
        RemoveUndo Space(6)
        InsertText = Space(6)
        
        SelStartSilent = where + 6
    End If
End If
glistN.enabled = True
    ReColorBlock
Render
nochange = False
End If
'glistN_MarkOut
Case Else

ctrl = False
End Select
noentrance = False
End Sub
Sub SearchDown(s$, Optional anystr As Boolean = False)
Dim l As Long, w As Long, TempLcid As Long, OldLcid As Long
w = mDoc.MarkParagraphID   ' this is the not the order
SelStartSilent = SelStart
l = Charpos + 1

OldLcid = mDoc.lcid
TempLcid = FoundLocaleId(s$)
If TempLcid <> 0 Then mDoc.lcid = TempLcid
If EditTextWord Or anystr Then
    If anystr Then
  If Not mDoc.FindStrDown(s$, w, l) Then GoTo sdnOut
  Else
    If Not mDoc.FindWord(s$, True, w, l) Then GoTo sdnOut
    End If
Else
    If Not mDoc.FindIdentifier(s$, True, w, l) Then GoTo sdnOut
End If
SelLengthSilent = 0
mDoc.MarkParagraphID = w
glistN.enabled = False
ParaSelStart = l
glistN.enabled = True
SelLength = Len(s$)
sdnOut:
mDoc.lcid = OldLcid
End Sub
Sub Searchup(s$, Optional anystr As Boolean = False)
Dim l As Long, w As Long, TempLcid As Long, OldLcid As Long
w = mDoc.MarkParagraphID
SelStartSilent = SelStart - (SelLength > 1)
l = Charpos + 1
OldLcid = mDoc.lcid
TempLcid = FoundLocaleId(s$)
If TempLcid <> 0 Then mDoc.lcid = TempLcid
If EditTextWord Or anystr Then
   If anystr Then
   If Not mDoc.FindStrUp(s$, w, l) Then GoTo sdupOut
   Else
       If Not mDoc.FindWord(s$, False, w, l) Then GoTo sdupOut
    End If
Else
    If Not mDoc.FindIdentifier(s$, False, w, l) Then GoTo sdupOut
End If
SelLengthSilent = 0
mDoc.MarkParagraphID = w
glistN.enabled = False
ParaSelStart = l
glistN.enabled = True
SelLength = Len(s$)
sdupOut:
mDoc.lcid = OldLcid
End Sub
Public Sub helpmeSub()
      If mIndex >= 0 Then
       Callback.Callback mesCtrlName + ".Help(" + Str(mIndex) + ",{" + Trim(SelText) + "})"
       Else
          Callback.Callback mesCtrlName + ".Help({" + Trim(SelText) + "})"
          End If
End Sub
Public Sub supsub()
Dim b$
b$ = s$
s$ = SelText
If s$ = vbNullString Or InStr(s$, Chr$(13)) > 0 Or InStr(s$, Chr$(10)) > 0 Then s$ = b$
Searchup s$
End Sub
Public Sub sdnSub()
Dim b$
b$ = s$
s$ = SelText
If s$ = vbNullString Or InStr(s$, Chr$(13)) > 0 Or InStr(s$, Chr$(10)) > 0 Then s$ = b$
SearchDown s$
End Sub
Public Sub mscatsub()
''
Dim l As Long, w As Long, s$, TempLcid As Long, OldLcid As Long
Dim el As Long, eW As Long, safety As Long, TT$

w = mDoc.MarkParagraphID
eW = w
SelStartSilent = SelStart  'MOVE CHARPOS TO SELSTART

el = Charpos  ' charpos maybe is in the start or the end of block
s$ = SelText
OldLcid = mDoc.lcid
TempLcid = FoundLocaleId(s$)
If TempLcid <> 0 Then mDoc.lcid = TempLcid

l = el + 1
If EditTextWord Then
Do
If mDoc.FindWord(s$, True, w, l) Then
TT$ = mDoc.TextParagraph(w)
Mid$(TT$, l, Len(s$)) = s$
mDoc.ReWritePara w, TT$
mDoc.WrapAgainBlock w, w
mDoc.ColorThis (w)
Else
w = 1
l = 0
safety = safety + 1
End If
Loop Until (w = eW And l = el) Or safety = 2

Else
Do
If mDoc.FindIdentifier(s$, True, w, l) Then
TT$ = mDoc.TextParagraph(w)
Mid$(TT$, l, Len(s$)) = s$
mDoc.TextParagraph(w) = TT$
mDoc.WrapAgainBlock w, w
mDoc.ColorThis (w)

Else
w = 1
l = 0
safety = safety + 1
End If
Loop Until (w = eW And l = el) Or safety = 2

End If
mDoc.lcid = OldLcid
Render
If glistN.Visible Then glistN.SetFocus
End Sub

Public Sub rthissub()
Dim l As Long, w As Long, s$, TempLcid As Long, OldLcid As Long
Dim el As Long, eW As Long, safety As Long, TT$, w1 As Long, i1 As Long
Dim neo$, mDoc10 As Document, addthat As Long, w2 As Long
w = mDoc.MarkParagraphID
eW = w
w2 = -1
SelStartSilent = SelStart  'MOVE CHARPOS TO SELSTART
el = Charpos  ' charpos maybe is in the start or the end of block
s$ = Trim$(SelText)
SelStartSilent = SelStart
el = Charpos  ' charpos maybe is in the start or the end of block

If pagio$ = "GREEK" Then
neo$ = InputBoxN("  (Shift  )", " ", s$)
Else
neo$ = InputBoxN("Replace Word (use Shift for Stop)", "Text Editor", s$)
End If
If neo$ = vbNullString Then Exit Sub
OldLcid = mDoc.lcid
TempLcid = FoundLocaleId(s$)
If TempLcid <> 0 Then mDoc.lcid = TempLcid
If Len(neo$) >= Len(s$) Then
    Set mDoc10 = New Document
    mDoc10 = neo$
    w1 = 0
    i1 = 0
    
    If EditTextWord Then
        If mDoc10.FindWord(s$, True, w1, i1) Then addthat = i1 - 1: If Len(neo$) = Len(s$) And addthat = 0 Then Exit Sub
    Else
        If mDoc10.FindIdentifier(s$, True, w1, i1) Then addthat = i1 - 1: If Len(neo$) = Len(s$) And addthat = 0 Then Exit Sub
    End If
    
End If

i1 = el
l = i1 + addthat
w1 = w
If EditTextWord Then
glistN.dropkey = True
Do
If mDoc.FindWord(s$, True, w, l) Then
If w2 > 0 Then If w2 <> w Then mDoc.WrapAgainBlock w2, w2:  mDoc.ColorThis w2
w2 = w
If safety And w = w1 Then

If l = i1 Then
 SelLengthSilent = 0
mDoc.MarkParagraphID = w
glistN.enabled = False
ParaSelStart = l
glistN.enabled = True
SelLength = Len(s$)
AddUndo ""
SelText = neo$
RemoveUndo neo$
Exit Do
ElseIf l - addthat < i1 Then
i1 = i1 + Len(neo$) - Len(s$)
Else

End If
End If
SelLengthSilent = 0
mDoc.MarkParagraphID = w
glistN.enabled = False
ParaSelStart = l
glistN.enabled = True
SelLength = Len(s$)
AddUndo ""
SelText = neo$

RemoveUndo neo$
l = l + Len(neo$)

Else
w = 1
l = 0
safety = safety + 1
End If
Loop Until safety = 2 Or KeyPressed(16)
glistN.dropkey = False

Else
''If l > 0 Then l = l - 1
glistN.dropkey = True
Do
If mDoc.FindIdentifier(s$, True, w, l) Then
If w2 > 0 Then If w2 <> w Then mDoc.WrapAgainBlock w2, w2:  mDoc.ColorThis w2
w2 = w
If safety And w = w1 Then
If l = i1 Then
 SelLengthSilent = 0
mDoc.MarkParagraphID = w
glistN.enabled = False
ParaSelStart = l
glistN.enabled = True
SelLength = Len(s$)
AddUndo ""
SelText = neo$
RemoveUndo neo$
Exit Do
ElseIf l - addthat < i1 Then
i1 = i1 + Len(neo$) - Len(s$)
Else

End If
End If
SelLengthSilent = 0
mDoc.MarkParagraphID = w
glistN.enabled = False
ParaSelStart = l
glistN.enabled = True
SelLength = Len(s$)
AddUndo ""
SelText = neo$
RemoveUndo neo$
l = l + Len(neo$)

Else
w = 1
l = 0
safety = safety + 1
End If
Loop Until safety = 2 Or KeyPressed(16)
glistN.dropkey = False
End If
mDoc.lcid = OldLcid
If w2 > 0 Then mDoc.WrapAgainBlock w2, w2:   mDoc.ColorThis w2
Render
If glistN.Visible Then glistN.SetFocus
End Sub
Private Sub MarkSoftButton(para As Long, pospara As Long)
If glistN.lines = 1 Then Exit Sub
If ShadowMarks Then Exit Sub
If para = 0 Then 'set
    para = mDoc.MarkParagraphID
    pospara = ParaSelStart
    
    If UserCodePage = 1253 Then
        ReplaceTitle = "       "
    Else
        ReplaceTitle = "Mark now move to this Paragraph and Position"
    End If
ElseIf para = mDoc.MarkParagraphID And pospara = Charpos Then 'Reset
    para = 0
    
    If UserCodePage = 1253 Then
    ReplaceTitle = " "
    Else
    ReplaceTitle = "Mark Deleted"
    End If
Else ' goto that paragraph
    If Not mDoc.InvalidPara(para) Then
        SelLengthSilent = 0
        mDoc.MarkParagraphID = para
        glistN.enabled = False
        ParaSelStart = pospara
        glistN.enabled = True
        ManualInform
    Else
        para = 0
        If UserCodePage = 1253 Then
            ReplaceTitle = "   -   "
        Else
            ReplaceTitle = "Paragraph no found - mark deleted"
        End If
    End If
End If
End Sub
Private Sub SetME()
If (600 - hueconv(backcolor)) Mod 360 > 30 And lightconv(backcolor) >= 128 Then ColorSet = 1 Else ColorSet = 0
Select Case fState
Case 0
'shortlang = False
NoColor = EditTextWord
Case 1
'shortlang = False
NoColor = True
Case 2
'shortlang = True
NoColor = EditTextWord
Case 3
'shortlang = True
NoColor = True
fState = -1
End Select
mDoc.ColorEvent = Not NoColor
End Sub
Private Function IsmineHere(a$) As Boolean
IsmineHere = InStr(mColorCollection1, "|" + UCase(a$) + "|") > 0
End Function
Private Function IsmineHere1(a$) As Boolean
IsmineHere1 = InStr(ColorCollection2, "|" + UCase(a$) + "|") > 0
End Function
Private Function IsmineHere2(a$) As Boolean
IsmineHere2 = InStr(ColorCollection3, "|" + UCase(a$) + "|") > 0
End Function
Private Function IsmineHere3(a$) As Boolean
IsmineHere3 = InStr(ColorCollection4, "|" + UCase(a$) + "|") > 0
End Function


Public Property Let MultiLineComment2(ByVal vNewValue As Variant)
mMultiLineComment2 = vNewValue
mDoc.final = vNewValue
End Property
Public Sub PopUpMenu(poptitle$, x As Variant, y As Variant)
Dim oldModalId As Variant, i As Long
''If UsedAsTextBox Then Exit Sub
i = SelLength
Form1mn1Enabled = i > 1
Form1mn2Enabled = i > 1
Form1mn3Enabled = Clipboard.GetFormat(13) Or Clipboard.GetFormat(1)
Form1sdnEnabled = i > 0 And (Length - SelStart) > SelLength
Form1supEnabled = i > 0 And SelStart > SelLength
Form1mscatEnabled = Form1sdnEnabled Or Form1supEnabled
Form1rthisEnabled = Form1mscatEnabled

oldModalId = Modalid
Modalid = Rnd * 113314324
'UnHook Callback.hWnd
MyPopUp.feedlabels Me, False
MyPopUp.UpGui Callback, x, y, poptitle$
MyPopUp.Visible = True
MyPopUp.ZOrder 0

        Do While MyPopUp.Visible
   ProcTask2 basestack1
   If Not Screen.ActiveForm Is Nothing Then
If GetForegroundWindow <> Screen.ActiveForm.hWND Then MyPopUp.Visible = False
End If
                '     mywait basestack1, 1
                If ExTarget Then Exit Do
                Loop
                Modalid = oldModalId
         '  Hook Callback.hWnd, Nothing
End Sub


Public Sub mn1sub()
MarkCut
End Sub

Public Sub mn2sub()
MarkCopy
End Sub

Public Sub mn3sub()
On Error Resume Next
Dim aa$
aa$ = GetTextData(13)
If aa$ = vbNullString Then aa$ = Clipboard.GetText(1)
If NumberOnly Or NumberIntOnly Then
    If Not ValidNum(aa$, False, NumberIntOnly) Then Exit Sub
    NumberOnly = True
    If Not mNoWrap = True Then
        mNoWrap = True
        glistN.NoScroll = False
    End If
ElseIf UsedAsTextBox Then
    aa$ = Replace(aa$, Chr(13), "")
    aa$ = Replace(aa$, Chr(10), "")
    If Not mNoWrap = True Then
        mNoWrap = True
        glistN.NoScroll = False
    End If
End If
If ParaSelStart = 2 And glistN.list(glistN.ListIndex) = vbNullString Then
SelStart = SelStart - 1
End If
AddUndo ""
SelText = aa$
RemoveUndo aa$
ReColorBlock
End Sub

Private Sub wdragSub()
glistN.DragEnabled = Not glistN.DragEnabled
End Sub

Public Sub wordwrapsub()
nowrap = Not nowrap
Render
ManualInform
End Sub
Public Sub Resize()
If Not nowrap Then WrapAll
Render
ManualInform
End Sub
Private Sub inform(tLine As Long, tPos As Long)
If UsedAsTextBox Then

Else
If UserCodePage = 1253 Then
textinform = "(" + CStr(tLine) + ")-(" + CStr(Charpos) + ")"

Else
textinform = "Line(" + CStr(tLine) + ")-Pos(" + CStr(Charpos) + ")"
End If

End If
End Sub

Public Property Get ColorCollection1() As Variant
ColorCollection1 = mColorCollection1
End Property

Public Property Let ColorCollection1(ByVal vNewValue As Variant)
mColorCollection1 = vNewValue
EditTextWord = vNewValue = vbNullString
SetME
End Property

Public Property Get NoColor() As Variant
NoColor = mNoColor
End Property

Public Property Let NoColor(ByVal vNewValue As Variant)
mNoColor = vNewValue
mNoColor1 = vNewValue
End Property
Public Property Let ShowAlways(ByVal vNewValue As Variant)
mStayOpen = CBool(vNewValue)
If mStayOpen Then
glistN.ForeColor = black 'rgb(0, 0, 0)
glistN.backcolor = white ' rgb(255, 255, 255)
End If
End Property

Sub GetFocus()
On Error Resume Next
Callback.Controls(ctrlName).SetFocus
End Sub
Sub ReColor()
On Error GoTo end1
Set Callback.mDoc = mDoc
WrapAll
If mDoc Is Nothing Then Set Callback.mDoc = Nothing: Exit Sub
Set Callback.mDoc = Nothing
ManualInform
end1:
End Sub
Private Sub ReColorBlock()
Dim order1, order2
order1 = 0: order2 = 0
If BlockEndPara <> BlockStartPara Then
order1 = mDoc.ParagraphOrder(BlockStartPara)
order2 = mDoc.ParagraphOrder(BlockEndPara)
End If
If order1 <= order2 Then
mDoc.WrapAgainBlock BlockStartPara, BlockEndPara
mDoc.WrapAgainColorBlock2 BlockStartPara, BlockEndPara
Else
mDoc.WrapAgainBlock BlockEndPara, BlockStartPara
mDoc.WrapAgainColorBlock2 BlockEndPara, BlockStartPara

End If
ManualInform
End Sub
Private Sub ColorBlockOnly()
Dim order1, order2
order1 = 0: order2 = 0
If BlockEndPara <> BlockStartPara Then
order1 = mDoc.ParagraphOrder(BlockStartPara)
order2 = mDoc.ParagraphOrder(BlockEndPara)
End If
If order1 <= order2 Then
mDoc.WrapAgainColorBlock2 BlockStartPara, BlockEndPara
Else
mDoc.WrapAgainColorBlock2 BlockEndPara, BlockStartPara
End If
''ManualInform
End Sub
Sub TextViewOnly()
mStayOpen = False
NoMark = True
mNoColor = True
mNoColor1 = True

EditDoc = False
glistN.PanPos = 0
nowrap = False
mDoc1.WrapAgain
glistN.ScrollTo 0
Me.SetRowColumn 1, 1, True
End Sub
Sub Transparent()
Dim x  As Long, y As Long
glistN.BackStyle = 1
glistN.GetLeftTop x, y
glistN.RepaintFromOut Callback.Image, x, y
End Sub
Sub ColorsReset()
white = rgb(255, 255, 255)
black = 0
dimm1 = rgb(100, 200, 160)
dimm2 = rgb(200, 120, 60)
End Sub
Sub Colors(white1, Optional black1, Optional dimm11, Optional dimm21)

white = mycolor(white1)
If Not IsMissing(black1) Then
black = mycolor(black1)
If Not IsMissing(dimm11) Then
dimm1 = dimm11
If Not IsMissing(dimm21) Then dimm2 = dimm21
End If
End If
Retired
End Sub
Public Sub Retired()
If mStayOpen Then
glistN.ForeColor = black
glistN.backcolor = white
glistN.NoCaretShow = False
Else
glistN.ForeColor = white
glistN.backcolor = dimm2
glistN.NoCaretShow = True
End If
 glistN.PanPos = 0: glistN.ShowMe
End Sub
Public Property Let DisplayLines(ByVal vNewValue As Variant)
glistN.addpixels = 0
glistN.restrictLines = CLng(vNewValue)
glistN.CalcNewFont
TextPixelOffset = Int(glistN.TextHeightOffset)
End Property

Private Sub mDoc_MayQuit(Yes As Variant)
If Quit Then Yes = True
'MyDoEvents1 Form3
End Sub


Public Property Get Value() As Variant
If Not (NumberOnly Or NumberIntOnly) Then Exit Property
NumberOnly = True
If mDoc.SizeCRLF = 0 Then
Value = 0
Else
If Not NumberIntOnly Then
If NowDec$ <> "." Then
Value = val(Replace$(Text, NowDec$, "."))
Else
Value = val(Replace$(Text, NowDec$, "."))
End If
Else
Value = val(Text)
End If
End If

End Property

Public Property Let Value(ByVal vNewValue As Variant)
NumberOnly = True
Dim content As String

If MyIsNumeric(vNewValue) Then
content = NLtrim$(Str(vNewValue))
If Not ValidNum(content, True, NumberIntOnly) Then
    Text = vbNullString
ElseIf vNewValue = 0 Then
    Text = vbNullString
Else
    Text = content
    End If
    Else
    Text = vbNullString
    End If
End Property
Public Property Let Default(RHS)
On Error Resume Next
If CBool(RHS) Then Callback.Default = ctrlName
End Property


Public Property Let WordCharLeft(ByVal vNewValue As String)
If Not glistN Is Nothing Then
glistN.WordCharLeft = vNewValue
End If
End Property

Public Property Let WordCharRight(ByVal vNewValue As String)
If Not glistN Is Nothing Then
glistN.WordCharRight = vNewValue
End If
End Property

Public Property Let WordCharRightButIncluded(ByVal vNewValue As String)
If Not glistN Is Nothing Then
glistN.WordCharRightButIncluded = vNewValue
End If

End Property
